// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/calvin.proto

package pb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	raftpb "go.etcd.io/etcd/raft/raftpb"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Id128 struct {
	Upper                uint64   `protobuf:"varint,1,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Lower                uint64   `protobuf:"varint,2,opt,name=Lower,proto3" json:"Lower,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id128) Reset()         { *m = Id128{} }
func (m *Id128) String() string { return proto.CompactTextString(m) }
func (*Id128) ProtoMessage()    {}
func (*Id128) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{0}
}
func (m *Id128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id128.Merge(m, src)
}
func (m *Id128) XXX_Size() int {
	return m.Size()
}
func (m *Id128) XXX_DiscardUnknown() {
	xxx_messageInfo_Id128.DiscardUnknown(m)
}

var xxx_messageInfo_Id128 proto.InternalMessageInfo

type Transaction struct {
	Id *Id128 `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// keys of the data objects that are being accessed
	// do I need this at all if I have read_write_set?
	WriteSet     [][]byte `protobuf:"bytes,2,rep,name=WriteSet,proto3" json:"WriteSet,omitempty"`
	ReadSet      [][]byte `protobuf:"bytes,3,rep,name=ReadSet,proto3" json:"ReadSet,omitempty"`
	ReadWriteSet [][]byte `protobuf:"bytes,4,rep,name=ReadWriteSet,proto3" json:"ReadWriteSet,omitempty"`
	// ids of the nodes that are being contacted
	ReaderNodes []int64 `protobuf:"varint,5,rep,packed,name=ReaderNodes,proto3" json:"ReaderNodes,omitempty"`
	WriterNodes []int64 `protobuf:"varint,6,rep,packed,name=WriterNodes,proto3" json:"WriterNodes,omitempty"`
	// the stored procedure that's being invoked
	StoredProcedure      string   `protobuf:"bytes,7,opt,name=StoredProcedure,proto3" json:"StoredProcedure,omitempty"`
	StoredProcedureArgs  [][]byte `protobuf:"bytes,8,rep,name=StoredProcedureArgs,proto3" json:"StoredProcedureArgs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{1}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type TransactionBatch struct {
	Transactions         []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	Epoch                uint64         `protobuf:"varint,2,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	NodeId               uint64         `protobuf:"varint,3,opt,name=NodeId,proto3" json:"NodeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransactionBatch) Reset()         { *m = TransactionBatch{} }
func (m *TransactionBatch) String() string { return proto.CompactTextString(m) }
func (*TransactionBatch) ProtoMessage()    {}
func (*TransactionBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{2}
}
func (m *TransactionBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBatch.Merge(m, src)
}
func (m *TransactionBatch) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBatch.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBatch proto.InternalMessageInfo

type SchedulerResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerResponse) Reset()         { *m = SchedulerResponse{} }
func (m *SchedulerResponse) String() string { return proto.CompactTextString(m) }
func (*SchedulerResponse) ProtoMessage()    {}
func (*SchedulerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{3}
}
func (m *SchedulerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerResponse.Merge(m, src)
}
func (m *SchedulerResponse) XXX_Size() int {
	return m.Size()
}
func (m *SchedulerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerResponse proto.InternalMessageInfo

type LowIsolationReadRequest struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadRequest) Reset()         { *m = LowIsolationReadRequest{} }
func (m *LowIsolationReadRequest) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadRequest) ProtoMessage()    {}
func (*LowIsolationReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{4}
}
func (m *LowIsolationReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadRequest.Merge(m, src)
}
func (m *LowIsolationReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadRequest proto.InternalMessageInfo

type LowIsolationReadResponse struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	Values               [][]byte `protobuf:"bytes,2,rep,name=Values,proto3" json:"Values,omitempty"`
	Term                 uint64   `protobuf:"varint,3,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64   `protobuf:"varint,4,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadResponse) Reset()         { *m = LowIsolationReadResponse{} }
func (m *LowIsolationReadResponse) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadResponse) ProtoMessage()    {}
func (*LowIsolationReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{5}
}
func (m *LowIsolationReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadResponse.Merge(m, src)
}
func (m *LowIsolationReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadResponse proto.InternalMessageInfo

type LockRequest struct {
	Txn                  *Transaction `protobuf:"bytes,1,opt,name=Txn,proto3" json:"Txn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LockRequest) Reset()         { *m = LockRequest{} }
func (m *LockRequest) String() string { return proto.CompactTextString(m) }
func (*LockRequest) ProtoMessage()    {}
func (*LockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{6}
}
func (m *LockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockRequest.Merge(m, src)
}
func (m *LockRequest) XXX_Size() int {
	return m.Size()
}
func (m *LockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LockRequest proto.InternalMessageInfo

type LockResponse struct {
	TxnId                *Id128   `protobuf:"bytes,1,opt,name=TxnId,proto3" json:"TxnId,omitempty"`
	AcquiredLock         bool     `protobuf:"varint,2,opt,name=AcquiredLock,proto3" json:"AcquiredLock,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockResponse) Reset()         { *m = LockResponse{} }
func (m *LockResponse) String() string { return proto.CompactTextString(m) }
func (*LockResponse) ProtoMessage()    {}
func (*LockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{7}
}
func (m *LockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockResponse.Merge(m, src)
}
func (m *LockResponse) XXX_Size() int {
	return m.Size()
}
func (m *LockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LockResponse proto.InternalMessageInfo

type StepReq struct {
	RaftNodeId           int64           `protobuf:"varint,1,opt,name=RaftNodeId,proto3" json:"RaftNodeId,omitempty"`
	Message              *raftpb.Message `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StepReq) Reset()         { *m = StepReq{} }
func (m *StepReq) String() string { return proto.CompactTextString(m) }
func (*StepReq) ProtoMessage()    {}
func (*StepReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{8}
}
func (m *StepReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepReq.Merge(m, src)
}
func (m *StepReq) XXX_Size() int {
	return m.Size()
}
func (m *StepReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StepReq.DiscardUnknown(m)
}

var xxx_messageInfo_StepReq proto.InternalMessageInfo

type StepResp struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StepResp) Reset()         { *m = StepResp{} }
func (m *StepResp) String() string { return proto.CompactTextString(m) }
func (*StepResp) ProtoMessage()    {}
func (*StepResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{9}
}
func (m *StepResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepResp.Merge(m, src)
}
func (m *StepResp) XXX_Size() int {
	return m.Size()
}
func (m *StepResp) XXX_DiscardUnknown() {
	xxx_messageInfo_StepResp.DiscardUnknown(m)
}

var xxx_messageInfo_StepResp proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Id128)(nil), "pb.Id128")
	proto.RegisterType((*Transaction)(nil), "pb.Transaction")
	proto.RegisterType((*TransactionBatch)(nil), "pb.TransactionBatch")
	proto.RegisterType((*SchedulerResponse)(nil), "pb.SchedulerResponse")
	proto.RegisterType((*LowIsolationReadRequest)(nil), "pb.LowIsolationReadRequest")
	proto.RegisterType((*LowIsolationReadResponse)(nil), "pb.LowIsolationReadResponse")
	proto.RegisterType((*LockRequest)(nil), "pb.LockRequest")
	proto.RegisterType((*LockResponse)(nil), "pb.LockResponse")
	proto.RegisterType((*StepReq)(nil), "pb.StepReq")
	proto.RegisterType((*StepResp)(nil), "pb.StepResp")
}

func init() { proto.RegisterFile("pb/calvin.proto", fileDescriptor_afc31d04251e05fb) }

var fileDescriptor_afc31d04251e05fb = []byte{
	// 682 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0x8e, 0xe3, 0xa4, 0x49, 0x26, 0x91, 0xd2, 0xdf, 0xfe, 0x02, 0x18, 0x83, 0x5c, 0xe3, 0x03,
	0xb8, 0x07, 0x92, 0x92, 0x4a, 0x08, 0x81, 0x10, 0x6a, 0xa5, 0x1e, 0x22, 0xca, 0x1f, 0x6d, 0x02,
	0x9c, 0x1d, 0x7b, 0x9a, 0x46, 0x04, 0xef, 0x76, 0xed, 0xb4, 0xe5, 0x4d, 0xe0, 0x06, 0x77, 0x1e,
	0xa4, 0xc7, 0x3e, 0x02, 0x2d, 0x97, 0x3e, 0x06, 0xda, 0x5d, 0x3b, 0x49, 0xd3, 0x70, 0x89, 0xf7,
	0xfb, 0xe6, 0xdb, 0xf1, 0xcc, 0x37, 0x13, 0x43, 0x93, 0x0f, 0x3b, 0x61, 0x30, 0x39, 0x1e, 0xc7,
	0x6d, 0x2e, 0x58, 0xca, 0x48, 0x91, 0x0f, 0xed, 0xd6, 0x88, 0x8d, 0x98, 0x82, 0x1d, 0x79, 0xd2,
	0x11, 0xfb, 0xe1, 0x88, 0xb5, 0x31, 0x0d, 0xa3, 0xf6, 0x98, 0x75, 0xe4, 0xb3, 0x23, 0x82, 0x83,
	0x54, 0xfd, 0xf0, 0xa1, 0x7a, 0x68, 0x9d, 0xf7, 0x12, 0xca, 0xbd, 0xe8, 0x49, 0xf7, 0x19, 0x69,
	0x41, 0xf9, 0x03, 0xe7, 0x28, 0x2c, 0xc3, 0x35, 0xfc, 0x12, 0xd5, 0x40, 0xb2, 0xfb, 0xec, 0x04,
	0x85, 0x55, 0xd4, 0xac, 0x02, 0xcf, 0xab, 0x57, 0x3f, 0x36, 0x8c, 0xab, 0x9f, 0x1b, 0x86, 0xf7,
	0xab, 0x08, 0xf5, 0x81, 0x08, 0xe2, 0x24, 0x08, 0xd3, 0x31, 0x8b, 0xc9, 0x5d, 0x28, 0xf6, 0x22,
	0x95, 0xa2, 0xde, 0xad, 0xb5, 0xf9, 0xb0, 0xad, 0x92, 0xd3, 0x62, 0x2f, 0x22, 0x36, 0x54, 0x3f,
	0x89, 0x71, 0x8a, 0x7d, 0x4c, 0xad, 0xa2, 0x6b, 0xfa, 0x0d, 0x3a, 0xc3, 0xc4, 0x82, 0x0a, 0xc5,
	0x20, 0x92, 0x21, 0x53, 0x85, 0x72, 0x48, 0x3c, 0x68, 0xc8, 0xe3, 0xec, 0x66, 0x49, 0x85, 0xaf,
	0x71, 0xc4, 0x85, 0xba, 0xc4, 0x28, 0xde, 0xb2, 0x08, 0x13, 0xab, 0xec, 0x9a, 0xbe, 0x49, 0x17,
	0x29, 0xa9, 0x50, 0xea, 0x4c, 0xb1, 0xa6, 0x15, 0x0b, 0x14, 0xf1, 0xa1, 0xd9, 0x4f, 0x99, 0xc0,
	0xe8, 0xbd, 0x60, 0x21, 0x46, 0x53, 0x81, 0x56, 0xc5, 0x35, 0xfc, 0x1a, 0x5d, 0xa6, 0xc9, 0x16,
	0xfc, 0xbf, 0x44, 0xed, 0x88, 0x51, 0x62, 0x55, 0x55, 0x61, 0xab, 0x42, 0x0b, 0x76, 0x4d, 0x61,
	0x7d, 0xc1, 0xad, 0xdd, 0x20, 0x0d, 0x0f, 0xc9, 0x36, 0x34, 0xd2, 0x39, 0x97, 0x58, 0x86, 0x6b,
	0xfa, 0xf5, 0x6e, 0x53, 0x9a, 0xb7, 0xa0, 0xa5, 0xd7, 0x44, 0x72, 0x2e, 0x7b, 0x9c, 0x85, 0x87,
	0xf9, 0x5c, 0x14, 0x20, 0xb7, 0x61, 0x4d, 0x76, 0xd3, 0x8b, 0x2c, 0x53, 0xd1, 0x19, 0xf2, 0x36,
	0xe1, 0xbf, 0x7e, 0x78, 0x88, 0xd1, 0x74, 0x82, 0x82, 0x62, 0xc2, 0x59, 0x9c, 0xa0, 0x4a, 0x21,
	0x04, 0xd3, 0x03, 0xaf, 0x51, 0x0d, 0xbc, 0xc7, 0x70, 0x67, 0x9f, 0x9d, 0xf4, 0x12, 0x36, 0x09,
	0xd4, 0x6b, 0x31, 0x88, 0x28, 0x1e, 0x4d, 0x31, 0x49, 0x09, 0x81, 0xd2, 0x6b, 0xfc, 0xaa, 0x0b,
	0x6c, 0x50, 0x75, 0xf6, 0x38, 0x58, 0x37, 0xe5, 0xd9, 0x0b, 0x56, 0xe8, 0x65, 0x85, 0x1f, 0x83,
	0xc9, 0x14, 0x93, 0x6c, 0x05, 0x32, 0x24, 0xb5, 0x03, 0x14, 0x5f, 0xb2, 0xba, 0xd5, 0x59, 0x16,
	0xd8, 0x8b, 0x23, 0x3c, 0xb5, 0x4a, 0xba, 0x47, 0x05, 0xbc, 0x2d, 0xa8, 0xef, 0xb3, 0xf0, 0x73,
	0x5e, 0xd4, 0x03, 0x30, 0x07, 0xa7, 0x71, 0xb6, 0x71, 0x37, 0x4c, 0x93, 0x31, 0xaf, 0x0f, 0x0d,
	0x7d, 0x23, 0xab, 0x6b, 0x03, 0xca, 0x83, 0xd3, 0x78, 0xd5, 0x9a, 0x6a, 0x5e, 0xee, 0xdc, 0x4e,
	0x78, 0x34, 0x1d, 0x0b, 0x8c, 0xe4, 0x45, 0xe5, 0x71, 0x95, 0x5e, 0xe3, 0xbc, 0x01, 0x54, 0xfa,
	0x29, 0x72, 0x8a, 0x47, 0xc4, 0x01, 0xa0, 0xc1, 0x41, 0x9a, 0x39, 0x2f, 0x93, 0x9a, 0x74, 0x81,
	0x21, 0x9b, 0x50, 0x79, 0x83, 0x49, 0x12, 0x8c, 0x50, 0x65, 0x92, 0x65, 0xea, 0xff, 0x61, 0x3b,
	0xa3, 0x69, 0x1e, 0xf7, 0x5c, 0xa8, 0xea, 0xac, 0x09, 0x5f, 0x3d, 0x9f, 0xee, 0x77, 0x03, 0x6a,
	0xb3, 0x59, 0x92, 0x17, 0x50, 0xcd, 0x01, 0x69, 0x2d, 0x35, 0xaf, 0xb6, 0xcb, 0xbe, 0x25, 0xd9,
	0x1b, 0xc3, 0xf7, 0x0a, 0xbe, 0x41, 0xde, 0xc1, 0xfa, 0xf2, 0xec, 0xc8, 0x3d, 0x29, 0xff, 0xc7,
	0x02, 0xd8, 0xf7, 0x57, 0x07, 0xf3, 0x94, 0xdd, 0x3d, 0x3d, 0x9a, 0x3e, 0x8a, 0xe3, 0x71, 0x88,
	0xe4, 0x29, 0xd4, 0x33, 0xcb, 0x24, 0x4b, 0x9a, 0xfa, 0xf6, 0x6c, 0x74, 0xf6, 0xfa, 0x9c, 0x98,
	0x57, 0xb5, 0x65, 0x74, 0x5f, 0x41, 0x4b, 0xba, 0xa7, 0x5a, 0xe1, 0x4c, 0xa4, 0x79, 0xbe, 0x47,
	0x50, 0x92, 0xe6, 0x90, 0xba, 0x6a, 0x49, 0x9b, 0x6f, 0x37, 0xe6, 0x20, 0xe1, 0x3a, 0xc1, 0xae,
	0x75, 0x76, 0xe1, 0x14, 0xce, 0x2f, 0x9c, 0xc2, 0xd9, 0xa5, 0x63, 0x9c, 0x5f, 0x3a, 0xc6, 0xef,
	0x4b, 0xc7, 0xf8, 0xf6, 0xc7, 0x29, 0x0c, 0xd7, 0xd4, 0x47, 0x6f, 0xfb, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x9c, 0x37, 0xd9, 0xd6, 0x49, 0x05, 0x00, 0x00,
}

func (this *Id128) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Upper != that1.Upper {
		if this.Upper < that1.Upper {
			return -1
		}
		return 1
	}
	if this.Lower != that1.Lower {
		if this.Lower < that1.Lower {
			return -1
		}
		return 1
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Transaction) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if len(this.WriteSet) != len(that1.WriteSet) {
		if len(this.WriteSet) < len(that1.WriteSet) {
			return -1
		}
		return 1
	}
	for i := range this.WriteSet {
		if c := bytes.Compare(this.WriteSet[i], that1.WriteSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		if len(this.ReadSet) < len(that1.ReadSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadSet {
		if c := bytes.Compare(this.ReadSet[i], that1.ReadSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		if len(this.ReadWriteSet) < len(that1.ReadWriteSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadWriteSet {
		if c := bytes.Compare(this.ReadWriteSet[i], that1.ReadWriteSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		if len(this.ReaderNodes) < len(that1.ReaderNodes) {
			return -1
		}
		return 1
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			if this.ReaderNodes[i] < that1.ReaderNodes[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		if len(this.WriterNodes) < len(that1.WriterNodes) {
			return -1
		}
		return 1
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			if this.WriterNodes[i] < that1.WriterNodes[i] {
				return -1
			}
			return 1
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		if this.StoredProcedure < that1.StoredProcedure {
			return -1
		}
		return 1
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		if len(this.StoredProcedureArgs) < len(that1.StoredProcedureArgs) {
			return -1
		}
		return 1
	}
	for i := range this.StoredProcedureArgs {
		if c := bytes.Compare(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]); c != 0 {
			return c
		}
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Id128) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Upper != that1.Upper {
		return false
	}
	if this.Lower != that1.Lower {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Transaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.WriteSet) != len(that1.WriteSet) {
		return false
	}
	for i := range this.WriteSet {
		if !bytes.Equal(this.WriteSet[i], that1.WriteSet[i]) {
			return false
		}
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		return false
	}
	for i := range this.ReadSet {
		if !bytes.Equal(this.ReadSet[i], that1.ReadSet[i]) {
			return false
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		return false
	}
	for i := range this.ReadWriteSet {
		if !bytes.Equal(this.ReadWriteSet[i], that1.ReadWriteSet[i]) {
			return false
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		return false
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			return false
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		return false
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			return false
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		return false
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		return false
	}
	for i := range this.StoredProcedureArgs {
		if !bytes.Equal(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchedulerClient interface {
	Schedule(ctx context.Context, opts ...grpc.CallOption) (Scheduler_ScheduleClient, error)
	LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) Schedule(ctx context.Context, opts ...grpc.CallOption) (Scheduler_ScheduleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Scheduler_serviceDesc.Streams[0], "/pb.Scheduler/Schedule", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerScheduleClient{stream}
	return x, nil
}

type Scheduler_ScheduleClient interface {
	Send(*TransactionBatch) error
	CloseAndRecv() (*SchedulerResponse, error)
	grpc.ClientStream
}

type schedulerScheduleClient struct {
	grpc.ClientStream
}

func (x *schedulerScheduleClient) Send(m *TransactionBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *schedulerScheduleClient) CloseAndRecv() (*SchedulerResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SchedulerResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *schedulerClient) LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error) {
	out := new(LowIsolationReadResponse)
	err := c.cc.Invoke(ctx, "/pb.Scheduler/LowIsolationRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerServer is the server API for Scheduler service.
type SchedulerServer interface {
	Schedule(Scheduler_ScheduleServer) error
	LowIsolationRead(context.Context, *LowIsolationReadRequest) (*LowIsolationReadResponse, error)
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_Schedule_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SchedulerServer).Schedule(&schedulerScheduleServer{stream})
}

type Scheduler_ScheduleServer interface {
	SendAndClose(*SchedulerResponse) error
	Recv() (*TransactionBatch, error)
	grpc.ServerStream
}

type schedulerScheduleServer struct {
	grpc.ServerStream
}

func (x *schedulerScheduleServer) SendAndClose(m *SchedulerResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *schedulerScheduleServer) Recv() (*TransactionBatch, error) {
	m := new(TransactionBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Scheduler_LowIsolationRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LowIsolationReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).LowIsolationRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Scheduler/LowIsolationRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).LowIsolationRead(ctx, req.(*LowIsolationReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LowIsolationRead",
			Handler:    _Scheduler_LowIsolationRead_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Schedule",
			Handler:       _Scheduler_Schedule_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pb/calvin.proto",
}

// LockServiceClient is the client API for LockService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LockServiceClient interface {
	AcquireLock(ctx context.Context, opts ...grpc.CallOption) (LockService_AcquireLockClient, error)
}

type lockServiceClient struct {
	cc *grpc.ClientConn
}

func NewLockServiceClient(cc *grpc.ClientConn) LockServiceClient {
	return &lockServiceClient{cc}
}

func (c *lockServiceClient) AcquireLock(ctx context.Context, opts ...grpc.CallOption) (LockService_AcquireLockClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LockService_serviceDesc.Streams[0], "/pb.LockService/AcquireLock", opts...)
	if err != nil {
		return nil, err
	}
	x := &lockServiceAcquireLockClient{stream}
	return x, nil
}

type LockService_AcquireLockClient interface {
	Send(*LockRequest) error
	Recv() (*LockResponse, error)
	grpc.ClientStream
}

type lockServiceAcquireLockClient struct {
	grpc.ClientStream
}

func (x *lockServiceAcquireLockClient) Send(m *LockRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lockServiceAcquireLockClient) Recv() (*LockResponse, error) {
	m := new(LockResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LockServiceServer is the server API for LockService service.
type LockServiceServer interface {
	AcquireLock(LockService_AcquireLockServer) error
}

func RegisterLockServiceServer(s *grpc.Server, srv LockServiceServer) {
	s.RegisterService(&_LockService_serviceDesc, srv)
}

func _LockService_AcquireLock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LockServiceServer).AcquireLock(&lockServiceAcquireLockServer{stream})
}

type LockService_AcquireLockServer interface {
	Send(*LockResponse) error
	Recv() (*LockRequest, error)
	grpc.ServerStream
}

type lockServiceAcquireLockServer struct {
	grpc.ServerStream
}

func (x *lockServiceAcquireLockServer) Send(m *LockResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lockServiceAcquireLockServer) Recv() (*LockRequest, error) {
	m := new(LockRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _LockService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.LockService",
	HandlerType: (*LockServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AcquireLock",
			Handler:       _LockService_AcquireLock_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/calvin.proto",
}

// RaftTransportServiceClient is the client API for RaftTransportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftTransportServiceClient interface {
	Step(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_StepClient, error)
}

type raftTransportServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportServiceClient(cc *grpc.ClientConn) RaftTransportServiceClient {
	return &raftTransportServiceClient{cc}
}

func (c *raftTransportServiceClient) Step(ctx context.Context, opts ...grpc.CallOption) (RaftTransportService_StepClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftTransportService_serviceDesc.Streams[0], "/pb.RaftTransportService/Step", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportServiceStepClient{stream}
	return x, nil
}

type RaftTransportService_StepClient interface {
	Send(*StepReq) error
	Recv() (*StepResp, error)
	grpc.ClientStream
}

type raftTransportServiceStepClient struct {
	grpc.ClientStream
}

func (x *raftTransportServiceStepClient) Send(m *StepReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportServiceStepClient) Recv() (*StepResp, error) {
	m := new(StepResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftTransportServiceServer is the server API for RaftTransportService service.
type RaftTransportServiceServer interface {
	Step(RaftTransportService_StepServer) error
}

func RegisterRaftTransportServiceServer(s *grpc.Server, srv RaftTransportServiceServer) {
	s.RegisterService(&_RaftTransportService_serviceDesc, srv)
}

func _RaftTransportService_Step_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServiceServer).Step(&raftTransportServiceStepServer{stream})
}

type RaftTransportService_StepServer interface {
	Send(*StepResp) error
	Recv() (*StepReq, error)
	grpc.ServerStream
}

type raftTransportServiceStepServer struct {
	grpc.ServerStream
}

func (x *raftTransportServiceStepServer) Send(m *StepResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportServiceStepServer) Recv() (*StepReq, error) {
	m := new(StepReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftTransportService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftTransportService",
	HandlerType: (*RaftTransportServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Step",
			Handler:       _RaftTransportService_Step_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/calvin.proto",
}

func (m *Id128) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id128) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Upper))
	}
	if m.Lower != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Id.Size()))
		n1, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.WriteSet) > 0 {
		for _, b := range m.WriteSet {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReaderNodes) > 0 {
		dAtA3 := make([]byte, len(m.ReaderNodes)*10)
		var j2 int
		for _, num1 := range m.ReaderNodes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.WriterNodes) > 0 {
		dAtA5 := make([]byte, len(m.WriterNodes)*10)
		var j4 int
		for _, num1 := range m.WriterNodes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.StoredProcedure) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.StoredProcedure)))
		i += copy(dAtA[i:], m.StoredProcedure)
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Epoch))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.NodeId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchedulerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Term))
	}
	if m.Index != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Txn.Size()))
		n6, err := m.Txn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.TxnId.Size()))
		n7, err := m.TxnId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.AcquiredLock {
		dAtA[i] = 0x10
		i++
		if m.AcquiredLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Message.Size()))
		n8, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCalvin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Id128) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upper != 0 {
		n += 1 + sovCalvin(uint64(m.Upper))
	}
	if m.Lower != 0 {
		n += 1 + sovCalvin(uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.WriteSet) > 0 {
		for _, b := range m.WriteSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReaderNodes) > 0 {
		l = 0
		for _, e := range m.ReaderNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	if len(m.WriterNodes) > 0 {
		l = 0
		for _, e := range m.WriterNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	l = len(m.StoredProcedure)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.Epoch != 0 {
		n += 1 + sovCalvin(uint64(m.Epoch))
	}
	if m.NodeId != 0 {
		n += 1 + sovCalvin(uint64(m.NodeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.Term != 0 {
		n += 1 + sovCalvin(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovCalvin(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnId != nil {
		l = m.TxnId.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.AcquiredLock {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		n += 1 + sovCalvin(uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCalvin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCalvin(x uint64) (n int) {
	return sovCalvin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Id128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &Id128{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteSet = append(m.WriteSet, make([]byte, postIndex-iNdEx))
			copy(m.WriteSet[len(m.WriteSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadSet = append(m.ReadSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadSet[len(m.ReadSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWriteSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadWriteSet = append(m.ReadWriteSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadWriteSet[len(m.ReadWriteSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReaderNodes = append(m.ReaderNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReaderNodes) == 0 {
					m.ReaderNodes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReaderNodes = append(m.ReaderNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderNodes", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WriterNodes = append(m.WriterNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WriterNodes) == 0 {
					m.WriterNodes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WriterNodes = append(m.WriterNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriterNodes", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedureArgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedureArgs = append(m.StoredProcedureArgs, make([]byte, postIndex-iNdEx))
			copy(m.StoredProcedureArgs[len(m.StoredProcedureArgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnId == nil {
				m.TxnId = &Id128{}
			}
			if err := m.TxnId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcquiredLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcquiredLock = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeId", wireType)
			}
			m.RaftNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftNodeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &raftpb.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCalvin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCalvin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCalvin
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCalvin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCalvin   = fmt.Errorf("proto: integer overflow")
)
