// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/calvin.proto

package pb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	raftpb "go.etcd.io/etcd/raft/raftpb"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Id128 struct {
	Upper                uint64   `protobuf:"varint,1,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Lower                uint64   `protobuf:"varint,2,opt,name=Lower,proto3" json:"Lower,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id128) Reset()         { *m = Id128{} }
func (m *Id128) String() string { return proto.CompactTextString(m) }
func (*Id128) ProtoMessage()    {}
func (*Id128) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{0}
}
func (m *Id128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id128.Merge(m, src)
}
func (m *Id128) XXX_Size() int {
	return m.Size()
}
func (m *Id128) XXX_DiscardUnknown() {
	xxx_messageInfo_Id128.DiscardUnknown(m)
}

var xxx_messageInfo_Id128 proto.InternalMessageInfo

type Transaction struct {
	Id *Id128 `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// keys of the data objects that are being accessed
	ReadSet      [][]byte `protobuf:"bytes,3,rep,name=ReadSet,proto3" json:"ReadSet,omitempty"`
	ReadWriteSet [][]byte `protobuf:"bytes,4,rep,name=ReadWriteSet,proto3" json:"ReadWriteSet,omitempty"`
	// ids of the nodes that are being contacted
	ReaderNodes []uint64 `protobuf:"varint,5,rep,packed,name=ReaderNodes,proto3" json:"ReaderNodes,omitempty"`
	WriterNodes []uint64 `protobuf:"varint,6,rep,packed,name=WriterNodes,proto3" json:"WriterNodes,omitempty"`
	// the stored procedure that's being invoked
	StoredProcedure      string   `protobuf:"bytes,7,opt,name=StoredProcedure,proto3" json:"StoredProcedure,omitempty"`
	StoredProcedureArgs  [][]byte `protobuf:"bytes,8,rep,name=StoredProcedureArgs,proto3" json:"StoredProcedureArgs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{1}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type TransactionBatch struct {
	Transactions         []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransactionBatch) Reset()         { *m = TransactionBatch{} }
func (m *TransactionBatch) String() string { return proto.CompactTextString(m) }
func (*TransactionBatch) ProtoMessage()    {}
func (*TransactionBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{2}
}
func (m *TransactionBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBatch.Merge(m, src)
}
func (m *TransactionBatch) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBatch.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBatch proto.InternalMessageInfo

type SchedulerResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerResponse) Reset()         { *m = SchedulerResponse{} }
func (m *SchedulerResponse) String() string { return proto.CompactTextString(m) }
func (*SchedulerResponse) ProtoMessage()    {}
func (*SchedulerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{3}
}
func (m *SchedulerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerResponse.Merge(m, src)
}
func (m *SchedulerResponse) XXX_Size() int {
	return m.Size()
}
func (m *SchedulerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerResponse proto.InternalMessageInfo

type LowIsolationReadRequest struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadRequest) Reset()         { *m = LowIsolationReadRequest{} }
func (m *LowIsolationReadRequest) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadRequest) ProtoMessage()    {}
func (*LowIsolationReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{4}
}
func (m *LowIsolationReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadRequest.Merge(m, src)
}
func (m *LowIsolationReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadRequest proto.InternalMessageInfo

type LowIsolationReadResponse struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	Values               [][]byte `protobuf:"bytes,2,rep,name=Values,proto3" json:"Values,omitempty"`
	Term                 uint64   `protobuf:"varint,3,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64   `protobuf:"varint,4,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadResponse) Reset()         { *m = LowIsolationReadResponse{} }
func (m *LowIsolationReadResponse) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadResponse) ProtoMessage()    {}
func (*LowIsolationReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{5}
}
func (m *LowIsolationReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadResponse.Merge(m, src)
}
func (m *LowIsolationReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadResponse proto.InternalMessageInfo

type RemoteReadRequest struct {
	TxnId                *Id128   `protobuf:"bytes,1,opt,name=TxnId,proto3" json:"TxnId,omitempty"`
	Keys                 [][]byte `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	Values               [][]byte `protobuf:"bytes,3,rep,name=Values,proto3" json:"Values,omitempty"`
	TotalNumLocks        uint32   `protobuf:"varint,4,opt,name=TotalNumLocks,proto3" json:"TotalNumLocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteReadRequest) Reset()         { *m = RemoteReadRequest{} }
func (m *RemoteReadRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteReadRequest) ProtoMessage()    {}
func (*RemoteReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{6}
}
func (m *RemoteReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteReadRequest.Merge(m, src)
}
func (m *RemoteReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoteReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteReadRequest proto.InternalMessageInfo

type RemoteReadResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteReadResponse) Reset()         { *m = RemoteReadResponse{} }
func (m *RemoteReadResponse) String() string { return proto.CompactTextString(m) }
func (*RemoteReadResponse) ProtoMessage()    {}
func (*RemoteReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{7}
}
func (m *RemoteReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteReadResponse.Merge(m, src)
}
func (m *RemoteReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoteReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteReadResponse proto.InternalMessageInfo

type RaftPeer struct {
	RaftNodeId           uint64   `protobuf:"varint,1,opt,name=RaftNodeId,proto3" json:"RaftNodeId,omitempty"`
	PeerAddress          string   `protobuf:"bytes,2,opt,name=PeerAddress,proto3" json:"PeerAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftPeer) Reset()         { *m = RaftPeer{} }
func (m *RaftPeer) String() string { return proto.CompactTextString(m) }
func (*RaftPeer) ProtoMessage()    {}
func (*RaftPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{8}
}
func (m *RaftPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftPeer.Merge(m, src)
}
func (m *RaftPeer) XXX_Size() int {
	return m.Size()
}
func (m *RaftPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftPeer.DiscardUnknown(m)
}

var xxx_messageInfo_RaftPeer proto.InternalMessageInfo

type StepRequest struct {
	RaftNodeId           int64           `protobuf:"varint,1,opt,name=RaftNodeId,proto3" json:"RaftNodeId,omitempty"`
	Message              *raftpb.Message `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StepRequest) Reset()         { *m = StepRequest{} }
func (m *StepRequest) String() string { return proto.CompactTextString(m) }
func (*StepRequest) ProtoMessage()    {}
func (*StepRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{9}
}
func (m *StepRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepRequest.Merge(m, src)
}
func (m *StepRequest) XXX_Size() int {
	return m.Size()
}
func (m *StepRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StepRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StepRequest proto.InternalMessageInfo

type StepResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StepResponse) Reset()         { *m = StepResponse{} }
func (m *StepResponse) String() string { return proto.CompactTextString(m) }
func (*StepResponse) ProtoMessage()    {}
func (*StepResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{10}
}
func (m *StepResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepResponse.Merge(m, src)
}
func (m *StepResponse) XXX_Size() int {
	return m.Size()
}
func (m *StepResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StepResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StepResponse proto.InternalMessageInfo

type SubmitTransactionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitTransactionRequest) Reset()         { *m = SubmitTransactionRequest{} }
func (m *SubmitTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitTransactionRequest) ProtoMessage()    {}
func (*SubmitTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{11}
}
func (m *SubmitTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionRequest.Merge(m, src)
}
func (m *SubmitTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionRequest proto.InternalMessageInfo

type SubmitTransactionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitTransactionResponse) Reset()         { *m = SubmitTransactionResponse{} }
func (m *SubmitTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitTransactionResponse) ProtoMessage()    {}
func (*SubmitTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{12}
}
func (m *SubmitTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionResponse.Merge(m, src)
}
func (m *SubmitTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Id128)(nil), "pb.Id128")
	proto.RegisterType((*Transaction)(nil), "pb.Transaction")
	proto.RegisterType((*TransactionBatch)(nil), "pb.TransactionBatch")
	proto.RegisterType((*SchedulerResponse)(nil), "pb.SchedulerResponse")
	proto.RegisterType((*LowIsolationReadRequest)(nil), "pb.LowIsolationReadRequest")
	proto.RegisterType((*LowIsolationReadResponse)(nil), "pb.LowIsolationReadResponse")
	proto.RegisterType((*RemoteReadRequest)(nil), "pb.RemoteReadRequest")
	proto.RegisterType((*RemoteReadResponse)(nil), "pb.RemoteReadResponse")
	proto.RegisterType((*RaftPeer)(nil), "pb.RaftPeer")
	proto.RegisterType((*StepRequest)(nil), "pb.StepRequest")
	proto.RegisterType((*StepResponse)(nil), "pb.StepResponse")
	proto.RegisterType((*SubmitTransactionRequest)(nil), "pb.SubmitTransactionRequest")
	proto.RegisterType((*SubmitTransactionResponse)(nil), "pb.SubmitTransactionResponse")
}

func init() { proto.RegisterFile("pb/calvin.proto", fileDescriptor_afc31d04251e05fb) }

var fileDescriptor_afc31d04251e05fb = []byte{
	// 699 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x52, 0x13, 0x4d,
	0x14, 0xcd, 0xe4, 0x0f, 0x72, 0x13, 0x0a, 0xe8, 0x8f, 0x0f, 0x9b, 0xa0, 0x21, 0x35, 0x45, 0x59,
	0x41, 0xcb, 0x44, 0xc3, 0xc6, 0xb2, 0x64, 0x01, 0x96, 0x65, 0xa5, 0x88, 0x48, 0x75, 0xe2, 0xcf,
	0x82, 0xcd, 0x24, 0x73, 0x09, 0x29, 0x93, 0xf4, 0xd8, 0xdd, 0x11, 0x7c, 0x01, 0xd7, 0x2e, 0x5d,
	0xea, 0xdb, 0xb0, 0xe4, 0x11, 0x04, 0x37, 0x3c, 0x86, 0xd5, 0xdd, 0x49, 0x98, 0xfc, 0xc0, 0x26,
	0xe9, 0x7b, 0xee, 0x99, 0x33, 0xa7, 0x6f, 0x9f, 0x1e, 0x58, 0x0c, 0x1a, 0xa5, 0xa6, 0xd7, 0xf9,
	0xda, 0xee, 0x15, 0x03, 0xc1, 0x15, 0x27, 0xd1, 0xa0, 0x91, 0x5d, 0x69, 0xf1, 0x16, 0x37, 0x65,
	0x49, 0xaf, 0x6c, 0x27, 0xfb, 0xb0, 0xc5, 0x8b, 0xa8, 0x9a, 0x7e, 0xb1, 0xcd, 0x4b, 0xfa, 0xbf,
	0x24, 0xbc, 0x63, 0x65, 0x7e, 0x82, 0x86, 0xf9, 0xb3, 0x3c, 0x77, 0x07, 0x12, 0x15, 0xff, 0x59,
	0xf9, 0x39, 0x59, 0x81, 0xc4, 0xfb, 0x20, 0x40, 0x41, 0x9d, 0xbc, 0x53, 0x88, 0x33, 0x5b, 0x68,
	0xb4, 0xca, 0x4f, 0x51, 0xd0, 0xa8, 0x45, 0x4d, 0xf1, 0x62, 0xfe, 0xfa, 0xd7, 0x86, 0x73, 0xfd,
	0x7b, 0xc3, 0x71, 0x7f, 0x44, 0x21, 0x5d, 0x17, 0x5e, 0x4f, 0x7a, 0x4d, 0xd5, 0xe6, 0x3d, 0xb2,
	0x06, 0xd1, 0x8a, 0x6f, 0x24, 0xd2, 0xe5, 0x54, 0x31, 0x68, 0x14, 0x8d, 0x38, 0x8b, 0x56, 0x7c,
	0x42, 0x61, 0x8e, 0xa1, 0xe7, 0xd7, 0x50, 0xd1, 0x58, 0x3e, 0x56, 0xc8, 0xb0, 0x61, 0x49, 0x5c,
	0xc8, 0xe8, 0xe5, 0x47, 0xd1, 0x56, 0xa8, 0xdb, 0x71, 0xd3, 0x1e, 0xc3, 0x48, 0x1e, 0xd2, 0xba,
	0x46, 0x71, 0xc0, 0x7d, 0x94, 0x34, 0x91, 0x8f, 0x15, 0xe2, 0x2c, 0x0c, 0x69, 0x86, 0x61, 0x0f,
	0x18, 0x49, 0xcb, 0x08, 0x41, 0xa4, 0x00, 0x8b, 0x35, 0xc5, 0x05, 0xfa, 0x87, 0x82, 0x37, 0xd1,
	0xef, 0x0b, 0xa4, 0x73, 0x79, 0xa7, 0x90, 0x62, 0x93, 0x30, 0x79, 0x0a, 0xff, 0x4d, 0x40, 0xbb,
	0xa2, 0x25, 0xe9, 0xbc, 0x31, 0x36, 0xab, 0x15, 0x1a, 0xc9, 0x1b, 0x58, 0x0a, 0x4d, 0x64, 0xcf,
	0x53, 0xcd, 0x13, 0xb2, 0x0d, 0x19, 0x75, 0x83, 0x49, 0xea, 0xe4, 0x63, 0x85, 0x74, 0x79, 0x51,
	0x0f, 0x28, 0xc4, 0x65, 0x63, 0x24, 0x77, 0x0b, 0x96, 0x6b, 0xcd, 0x13, 0xf4, 0xfb, 0x1d, 0x14,
	0x0c, 0x65, 0xc0, 0x7b, 0x12, 0xf5, 0x81, 0xbc, 0x16, 0x82, 0xdb, 0x63, 0x4a, 0x31, 0x5b, 0xb8,
	0x4f, 0xe0, 0x5e, 0x95, 0x9f, 0x56, 0x24, 0xef, 0x78, 0x46, 0x08, 0x3d, 0x9f, 0xe1, 0x97, 0x3e,
	0x4a, 0x45, 0x08, 0xc4, 0xf7, 0xf1, 0x9b, 0x7d, 0x65, 0x86, 0x99, 0xb5, 0x1b, 0x00, 0x9d, 0xa6,
	0x0f, 0x5e, 0x30, 0x83, 0x4f, 0x56, 0x21, 0xf9, 0xc1, 0xeb, 0xf4, 0x51, 0xd2, 0xa8, 0x41, 0x07,
	0x95, 0xe6, 0xd6, 0x51, 0x74, 0x69, 0xcc, 0x84, 0xc3, 0xac, 0xb5, 0xc1, 0x4a, 0xcf, 0xc7, 0x33,
	0x1a, 0xb7, 0x89, 0x31, 0x85, 0xfb, 0xdd, 0x81, 0x65, 0x86, 0x5d, 0xae, 0x30, 0xec, 0x6d, 0x03,
	0x12, 0xf5, 0xb3, 0xde, 0xac, 0xc0, 0x58, 0x7c, 0x64, 0x26, 0x3a, 0xd3, 0x4c, 0x6c, 0xcc, 0xcc,
	0x26, 0x2c, 0xd4, 0xb9, 0xf2, 0x3a, 0x07, 0xfd, 0x6e, 0x95, 0x37, 0x3f, 0x4b, 0x63, 0x60, 0x81,
	0x8d, 0x83, 0xee, 0x23, 0x20, 0x61, 0x1f, 0x77, 0x4e, 0xb5, 0x0a, 0xf3, 0xcc, 0x3b, 0x56, 0x87,
	0x88, 0x82, 0xe4, 0x00, 0xf4, 0x5a, 0x07, 0x69, 0xe0, 0x37, 0xce, 0x42, 0x88, 0x4e, 0x9f, 0xe6,
	0xed, 0xfa, 0xbe, 0x40, 0x29, 0xcd, 0x75, 0x49, 0xb1, 0x30, 0xe4, 0x7e, 0x82, 0x74, 0x4d, 0x61,
	0x30, 0xdc, 0xfb, 0xb4, 0x60, 0x6c, 0x4c, 0x70, 0x0b, 0xe6, 0xde, 0xa2, 0x94, 0x5e, 0x0b, 0x8d,
	0x98, 0x4e, 0x8b, 0xbd, 0xbd, 0xc5, 0x01, 0xcc, 0x86, 0x7d, 0x77, 0x13, 0x32, 0x56, 0xf9, 0xce,
	0xdd, 0x64, 0x81, 0xd6, 0xfa, 0x8d, 0x6e, 0x5b, 0x85, 0x13, 0x67, 0xcd, 0xb8, 0xeb, 0xb0, 0x36,
	0xa3, 0x67, 0xe5, 0xca, 0x47, 0x90, 0x1a, 0xe5, 0x90, 0xbc, 0x83, 0xa5, 0xc9, 0xe8, 0x90, 0x75,
	0x7d, 0x6e, 0xb7, 0xe4, 0x2f, 0x7b, 0x7f, 0x76, 0xd3, 0x6a, 0xbb, 0x91, 0xf2, 0x3e, 0xc0, 0xcd,
	0x81, 0x90, 0x9d, 0xb1, 0xea, 0x7f, 0xfd, 0xec, 0x54, 0x6c, 0xb2, 0xab, 0x93, 0xf0, 0x48, 0xec,
	0x25, 0x2c, 0xe8, 0x11, 0x9a, 0x5d, 0x04, 0x5c, 0x28, 0xf2, 0x18, 0xe2, 0x7a, 0x34, 0xc4, 0x5c,
	0xb5, 0xd0, 0xf8, 0xb3, 0x4b, 0x37, 0xc0, 0xe8, 0xe9, 0x23, 0x48, 0xbe, 0x32, 0x5f, 0x57, 0xc2,
	0x60, 0x79, 0x6a, 0x1e, 0xc4, 0xec, 0xe4, 0xb6, 0x11, 0x66, 0x1f, 0xdc, 0xd2, 0x1d, 0xaa, 0xef,
	0xd1, 0xf3, 0xcb, 0x5c, 0xe4, 0xe2, 0x32, 0x17, 0x39, 0xbf, 0xca, 0x39, 0x17, 0x57, 0x39, 0xe7,
	0xcf, 0x55, 0xce, 0xf9, 0xf9, 0x37, 0x17, 0x69, 0x24, 0xcd, 0xa7, 0x78, 0xfb, 0x5f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xee, 0x19, 0xac, 0x29, 0xdf, 0x05, 0x00, 0x00,
}

func (this *Id128) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Upper != that1.Upper {
		if this.Upper < that1.Upper {
			return -1
		}
		return 1
	}
	if this.Lower != that1.Lower {
		if this.Lower < that1.Lower {
			return -1
		}
		return 1
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Transaction) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		if len(this.ReadSet) < len(that1.ReadSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadSet {
		if c := bytes.Compare(this.ReadSet[i], that1.ReadSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		if len(this.ReadWriteSet) < len(that1.ReadWriteSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadWriteSet {
		if c := bytes.Compare(this.ReadWriteSet[i], that1.ReadWriteSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		if len(this.ReaderNodes) < len(that1.ReaderNodes) {
			return -1
		}
		return 1
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			if this.ReaderNodes[i] < that1.ReaderNodes[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		if len(this.WriterNodes) < len(that1.WriterNodes) {
			return -1
		}
		return 1
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			if this.WriterNodes[i] < that1.WriterNodes[i] {
				return -1
			}
			return 1
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		if this.StoredProcedure < that1.StoredProcedure {
			return -1
		}
		return 1
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		if len(this.StoredProcedureArgs) < len(that1.StoredProcedureArgs) {
			return -1
		}
		return 1
	}
	for i := range this.StoredProcedureArgs {
		if c := bytes.Compare(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]); c != 0 {
			return c
		}
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Id128) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Upper != that1.Upper {
		return false
	}
	if this.Lower != that1.Lower {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Transaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		return false
	}
	for i := range this.ReadSet {
		if !bytes.Equal(this.ReadSet[i], that1.ReadSet[i]) {
			return false
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		return false
	}
	for i := range this.ReadWriteSet {
		if !bytes.Equal(this.ReadWriteSet[i], that1.ReadWriteSet[i]) {
			return false
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		return false
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			return false
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		return false
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			return false
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		return false
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		return false
	}
	for i := range this.StoredProcedureArgs {
		if !bytes.Equal(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchedulerClient interface {
	LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error) {
	out := new(LowIsolationReadResponse)
	err := c.cc.Invoke(ctx, "/pb.Scheduler/LowIsolationRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerServer is the server API for Scheduler service.
type SchedulerServer interface {
	LowIsolationRead(context.Context, *LowIsolationReadRequest) (*LowIsolationReadResponse, error)
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_LowIsolationRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LowIsolationReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).LowIsolationRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Scheduler/LowIsolationRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).LowIsolationRead(ctx, req.(*LowIsolationReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LowIsolationRead",
			Handler:    _Scheduler_LowIsolationRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

// RemoteReadClient is the client API for RemoteRead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RemoteReadClient interface {
	RemoteRead(ctx context.Context, in *RemoteReadRequest, opts ...grpc.CallOption) (*RemoteReadResponse, error)
}

type remoteReadClient struct {
	cc *grpc.ClientConn
}

func NewRemoteReadClient(cc *grpc.ClientConn) RemoteReadClient {
	return &remoteReadClient{cc}
}

func (c *remoteReadClient) RemoteRead(ctx context.Context, in *RemoteReadRequest, opts ...grpc.CallOption) (*RemoteReadResponse, error) {
	out := new(RemoteReadResponse)
	err := c.cc.Invoke(ctx, "/pb.RemoteRead/RemoteRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoteReadServer is the server API for RemoteRead service.
type RemoteReadServer interface {
	RemoteRead(context.Context, *RemoteReadRequest) (*RemoteReadResponse, error)
}

func RegisterRemoteReadServer(s *grpc.Server, srv RemoteReadServer) {
	s.RegisterService(&_RemoteRead_serviceDesc, srv)
}

func _RemoteRead_RemoteRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteReadServer).RemoteRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RemoteRead/RemoteRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteReadServer).RemoteRead(ctx, req.(*RemoteReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RemoteRead_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RemoteRead",
	HandlerType: (*RemoteReadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoteRead",
			Handler:    _RemoteRead_RemoteRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

// RaftTransportClient is the client API for RaftTransport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftTransportClient interface {
	Step(ctx context.Context, in *StepRequest, opts ...grpc.CallOption) (*StepResponse, error)
}

type raftTransportClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportClient(cc *grpc.ClientConn) RaftTransportClient {
	return &raftTransportClient{cc}
}

func (c *raftTransportClient) Step(ctx context.Context, in *StepRequest, opts ...grpc.CallOption) (*StepResponse, error) {
	out := new(StepResponse)
	err := c.cc.Invoke(ctx, "/pb.RaftTransport/Step", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftTransportServer is the server API for RaftTransport service.
type RaftTransportServer interface {
	Step(context.Context, *StepRequest) (*StepResponse, error)
}

func RegisterRaftTransportServer(s *grpc.Server, srv RaftTransportServer) {
	s.RegisterService(&_RaftTransport_serviceDesc, srv)
}

func _RaftTransport_Step_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftTransportServer).Step(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftTransport/Step",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftTransportServer).Step(ctx, req.(*StepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftTransport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftTransport",
	HandlerType: (*RaftTransportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Step",
			Handler:    _RaftTransport_Step_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

// CalvinClient is the client API for Calvin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CalvinClient interface {
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
}

type calvinClient struct {
	cc *grpc.ClientConn
}

func NewCalvinClient(cc *grpc.ClientConn) CalvinClient {
	return &calvinClient{cc}
}

func (c *calvinClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.Calvin/SubmitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalvinServer is the server API for Calvin service.
type CalvinServer interface {
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
}

func RegisterCalvinServer(s *grpc.Server, srv CalvinServer) {
	s.RegisterService(&_Calvin_serviceDesc, srv)
}

func _Calvin_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalvinServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Calvin/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalvinServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Calvin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Calvin",
	HandlerType: (*CalvinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitTransaction",
			Handler:    _Calvin_SubmitTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

func (m *Id128) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id128) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Upper))
	}
	if m.Lower != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Id.Size()))
		n1, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReaderNodes) > 0 {
		dAtA3 := make([]byte, len(m.ReaderNodes)*10)
		var j2 int
		for _, num := range m.ReaderNodes {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.WriterNodes) > 0 {
		dAtA5 := make([]byte, len(m.WriterNodes)*10)
		var j4 int
		for _, num := range m.WriterNodes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.StoredProcedure) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.StoredProcedure)))
		i += copy(dAtA[i:], m.StoredProcedure)
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchedulerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Term))
	}
	if m.Index != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.TxnId.Size()))
		n6, err := m.TxnId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.TotalNumLocks != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.TotalNumLocks))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.RaftNodeId))
	}
	if len(m.PeerAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.PeerAddress)))
		i += copy(dAtA[i:], m.PeerAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Message.Size()))
		n7, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmitTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmitTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCalvin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Id128) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upper != 0 {
		n += 1 + sovCalvin(uint64(m.Upper))
	}
	if m.Lower != 0 {
		n += 1 + sovCalvin(uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReaderNodes) > 0 {
		l = 0
		for _, e := range m.ReaderNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	if len(m.WriterNodes) > 0 {
		l = 0
		for _, e := range m.WriterNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	l = len(m.StoredProcedure)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.Term != 0 {
		n += 1 + sovCalvin(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovCalvin(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnId != nil {
		l = m.TxnId.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.TotalNumLocks != 0 {
		n += 1 + sovCalvin(uint64(m.TotalNumLocks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		n += 1 + sovCalvin(uint64(m.RaftNodeId))
	}
	l = len(m.PeerAddress)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		n += 1 + sovCalvin(uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCalvin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCalvin(x uint64) (n int) {
	return sovCalvin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Id128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &Id128{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadSet = append(m.ReadSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadSet[len(m.ReadSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWriteSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadWriteSet = append(m.ReadWriteSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadWriteSet[len(m.ReadWriteSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReaderNodes = append(m.ReaderNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReaderNodes) == 0 {
					m.ReaderNodes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReaderNodes = append(m.ReaderNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderNodes", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WriterNodes = append(m.WriterNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WriterNodes) == 0 {
					m.WriterNodes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WriterNodes = append(m.WriterNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriterNodes", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedureArgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedureArgs = append(m.StoredProcedureArgs, make([]byte, postIndex-iNdEx))
			copy(m.StoredProcedureArgs[len(m.StoredProcedureArgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnId == nil {
				m.TxnId = &Id128{}
			}
			if err := m.TxnId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNumLocks", wireType)
			}
			m.TotalNumLocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNumLocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeId", wireType)
			}
			m.RaftNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftNodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeId", wireType)
			}
			m.RaftNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftNodeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &raftpb.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCalvin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCalvin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCalvin
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCalvin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCalvin   = fmt.Errorf("proto: integer overflow")
)
