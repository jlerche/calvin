// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/calvin.proto

package pb

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	raftpb "go.etcd.io/etcd/raft/raftpb"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MessageType int32

const (
	TRANSACTION  MessageType = 0
	LOW_ISO_READ MessageType = 1
)

var MessageType_name = map[int32]string{
	0: "TRANSACTION",
	1: "LOW_ISO_READ",
}

var MessageType_value = map[string]int32{
	"TRANSACTION":  0,
	"LOW_ISO_READ": 1,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{0}
}

type SimpleSetterArg struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleSetterArg) Reset()         { *m = SimpleSetterArg{} }
func (m *SimpleSetterArg) String() string { return proto.CompactTextString(m) }
func (*SimpleSetterArg) ProtoMessage()    {}
func (*SimpleSetterArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{0}
}
func (m *SimpleSetterArg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleSetterArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleSetterArg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleSetterArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleSetterArg.Merge(m, src)
}
func (m *SimpleSetterArg) XXX_Size() int {
	return m.Size()
}
func (m *SimpleSetterArg) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleSetterArg.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleSetterArg proto.InternalMessageInfo

type Id128 struct {
	Upper                uint64   `protobuf:"varint,1,opt,name=Upper,proto3" json:"Upper,omitempty"`
	Lower                uint64   `protobuf:"varint,2,opt,name=Lower,proto3" json:"Lower,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id128) Reset()         { *m = Id128{} }
func (m *Id128) String() string { return proto.CompactTextString(m) }
func (*Id128) ProtoMessage()    {}
func (*Id128) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{1}
}
func (m *Id128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Id128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Id128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Id128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id128.Merge(m, src)
}
func (m *Id128) XXX_Size() int {
	return m.Size()
}
func (m *Id128) XXX_DiscardUnknown() {
	xxx_messageInfo_Id128.DiscardUnknown(m)
}

var xxx_messageInfo_Id128 proto.InternalMessageInfo

type BaseMessage struct {
	Type                 MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MessageType" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BaseMessage) Reset()         { *m = BaseMessage{} }
func (m *BaseMessage) String() string { return proto.CompactTextString(m) }
func (*BaseMessage) ProtoMessage()    {}
func (*BaseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{2}
}
func (m *BaseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseMessage.Merge(m, src)
}
func (m *BaseMessage) XXX_Size() int {
	return m.Size()
}
func (m *BaseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_BaseMessage proto.InternalMessageInfo

type Transaction struct {
	Type MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MessageType" json:"Type,omitempty"`
	Id   *Id128      `protobuf:"bytes,2,opt,name=Id,proto3" json:"Id,omitempty"`
	// keys of the data objects that are being accessed
	ReadSet      [][]byte `protobuf:"bytes,3,rep,name=ReadSet,proto3" json:"ReadSet,omitempty"`
	ReadWriteSet [][]byte `protobuf:"bytes,4,rep,name=ReadWriteSet,proto3" json:"ReadWriteSet,omitempty"`
	// ids of the nodes that are being contacted
	ReaderNodes []uint64 `protobuf:"varint,5,rep,packed,name=ReaderNodes,proto3" json:"ReaderNodes,omitempty"`
	WriterNodes []uint64 `protobuf:"varint,6,rep,packed,name=WriterNodes,proto3" json:"WriterNodes,omitempty"`
	// the stored procedure that's being invoked
	StoredProcedure     string   `protobuf:"bytes,7,opt,name=StoredProcedure,proto3" json:"StoredProcedure,omitempty"`
	StoredProcedureArgs [][]byte `protobuf:"bytes,8,rep,name=StoredProcedureArgs,proto3" json:"StoredProcedureArgs,omitempty"`
	// only true when the transaction is a low isolation read
	// in that case LowIsolationReadResponse is populated by the execution routines
	// a nifty way to get this info from the execution back to the scheduler
	IsLowIsolationRead       bool                      `protobuf:"varint,9,opt,name=IsLowIsolationRead,proto3" json:"IsLowIsolationRead,omitempty"`
	LowIsolationReadResponse *LowIsolationReadResponse `protobuf:"bytes,10,opt,name=LowIsolationReadResponse,proto3" json:"LowIsolationReadResponse,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
	XXX_unrecognized         []byte                    `json:"-"`
	XXX_sizecache            int32                     `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{3}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type LowIsoRead struct {
	Type                     MessageType               `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MessageType" json:"Type,omitempty"`
	LowIsolationReadResponse *LowIsolationReadResponse `protobuf:"bytes,2,opt,name=LowIsolationReadResponse,proto3" json:"LowIsolationReadResponse,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
	XXX_unrecognized         []byte                    `json:"-"`
	XXX_sizecache            int32                     `json:"-"`
}

func (m *LowIsoRead) Reset()         { *m = LowIsoRead{} }
func (m *LowIsoRead) String() string { return proto.CompactTextString(m) }
func (*LowIsoRead) ProtoMessage()    {}
func (*LowIsoRead) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{4}
}
func (m *LowIsoRead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsoRead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsoRead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsoRead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsoRead.Merge(m, src)
}
func (m *LowIsoRead) XXX_Size() int {
	return m.Size()
}
func (m *LowIsoRead) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsoRead.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsoRead proto.InternalMessageInfo

type TransactionBatch struct {
	Transactions         []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransactionBatch) Reset()         { *m = TransactionBatch{} }
func (m *TransactionBatch) String() string { return proto.CompactTextString(m) }
func (*TransactionBatch) ProtoMessage()    {}
func (*TransactionBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{5}
}
func (m *TransactionBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBatch.Merge(m, src)
}
func (m *TransactionBatch) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBatch.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBatch proto.InternalMessageInfo

type LowIsolationReadRequest struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadRequest) Reset()         { *m = LowIsolationReadRequest{} }
func (m *LowIsolationReadRequest) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadRequest) ProtoMessage()    {}
func (*LowIsolationReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{6}
}
func (m *LowIsolationReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadRequest.Merge(m, src)
}
func (m *LowIsolationReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadRequest proto.InternalMessageInfo

type LowIsolationReadResponse struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=Keys,proto3" json:"Keys,omitempty"`
	Values               [][]byte `protobuf:"bytes,2,rep,name=Values,proto3" json:"Values,omitempty"`
	Term                 uint64   `protobuf:"varint,3,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64   `protobuf:"varint,4,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LowIsolationReadResponse) Reset()         { *m = LowIsolationReadResponse{} }
func (m *LowIsolationReadResponse) String() string { return proto.CompactTextString(m) }
func (*LowIsolationReadResponse) ProtoMessage()    {}
func (*LowIsolationReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{7}
}
func (m *LowIsolationReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LowIsolationReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LowIsolationReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LowIsolationReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LowIsolationReadResponse.Merge(m, src)
}
func (m *LowIsolationReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *LowIsolationReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LowIsolationReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LowIsolationReadResponse proto.InternalMessageInfo

type RemoteReadRequest struct {
	TxnId                *Id128   `protobuf:"bytes,1,opt,name=TxnId,proto3" json:"TxnId,omitempty"`
	Keys                 [][]byte `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	Values               [][]byte `protobuf:"bytes,3,rep,name=Values,proto3" json:"Values,omitempty"`
	TotalNumLocks        uint32   `protobuf:"varint,4,opt,name=TotalNumLocks,proto3" json:"TotalNumLocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteReadRequest) Reset()         { *m = RemoteReadRequest{} }
func (m *RemoteReadRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteReadRequest) ProtoMessage()    {}
func (*RemoteReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{8}
}
func (m *RemoteReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteReadRequest.Merge(m, src)
}
func (m *RemoteReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoteReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteReadRequest proto.InternalMessageInfo

type RemoteReadResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteReadResponse) Reset()         { *m = RemoteReadResponse{} }
func (m *RemoteReadResponse) String() string { return proto.CompactTextString(m) }
func (*RemoteReadResponse) ProtoMessage()    {}
func (*RemoteReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{9}
}
func (m *RemoteReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteReadResponse.Merge(m, src)
}
func (m *RemoteReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoteReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteReadResponse proto.InternalMessageInfo

type RaftPeer struct {
	RaftNodeId           uint64   `protobuf:"varint,1,opt,name=RaftNodeId,proto3" json:"RaftNodeId,omitempty"`
	PeerAddress          string   `protobuf:"bytes,2,opt,name=PeerAddress,proto3" json:"PeerAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftPeer) Reset()         { *m = RaftPeer{} }
func (m *RaftPeer) String() string { return proto.CompactTextString(m) }
func (*RaftPeer) ProtoMessage()    {}
func (*RaftPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{10}
}
func (m *RaftPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftPeer.Merge(m, src)
}
func (m *RaftPeer) XXX_Size() int {
	return m.Size()
}
func (m *RaftPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftPeer.DiscardUnknown(m)
}

var xxx_messageInfo_RaftPeer proto.InternalMessageInfo

type StepRequest struct {
	RaftNodeId           uint64          `protobuf:"varint,1,opt,name=RaftNodeId,proto3" json:"RaftNodeId,omitempty"`
	Message              *raftpb.Message `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StepRequest) Reset()         { *m = StepRequest{} }
func (m *StepRequest) String() string { return proto.CompactTextString(m) }
func (*StepRequest) ProtoMessage()    {}
func (*StepRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{11}
}
func (m *StepRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepRequest.Merge(m, src)
}
func (m *StepRequest) XXX_Size() int {
	return m.Size()
}
func (m *StepRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StepRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StepRequest proto.InternalMessageInfo

type StepResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StepResponse) Reset()         { *m = StepResponse{} }
func (m *StepResponse) String() string { return proto.CompactTextString(m) }
func (*StepResponse) ProtoMessage()    {}
func (*StepResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{12}
}
func (m *StepResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepResponse.Merge(m, src)
}
func (m *StepResponse) XXX_Size() int {
	return m.Size()
}
func (m *StepResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StepResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StepResponse proto.InternalMessageInfo

type SubmitTransactionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitTransactionRequest) Reset()         { *m = SubmitTransactionRequest{} }
func (m *SubmitTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitTransactionRequest) ProtoMessage()    {}
func (*SubmitTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{13}
}
func (m *SubmitTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionRequest.Merge(m, src)
}
func (m *SubmitTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionRequest proto.InternalMessageInfo

type SubmitTransactionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitTransactionResponse) Reset()         { *m = SubmitTransactionResponse{} }
func (m *SubmitTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitTransactionResponse) ProtoMessage()    {}
func (*SubmitTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afc31d04251e05fb, []int{14}
}
func (m *SubmitTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionResponse.Merge(m, src)
}
func (m *SubmitTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("pb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*SimpleSetterArg)(nil), "pb.SimpleSetterArg")
	proto.RegisterType((*Id128)(nil), "pb.Id128")
	proto.RegisterType((*BaseMessage)(nil), "pb.BaseMessage")
	proto.RegisterType((*Transaction)(nil), "pb.Transaction")
	proto.RegisterType((*LowIsoRead)(nil), "pb.LowIsoRead")
	proto.RegisterType((*TransactionBatch)(nil), "pb.TransactionBatch")
	proto.RegisterType((*LowIsolationReadRequest)(nil), "pb.LowIsolationReadRequest")
	proto.RegisterType((*LowIsolationReadResponse)(nil), "pb.LowIsolationReadResponse")
	proto.RegisterType((*RemoteReadRequest)(nil), "pb.RemoteReadRequest")
	proto.RegisterType((*RemoteReadResponse)(nil), "pb.RemoteReadResponse")
	proto.RegisterType((*RaftPeer)(nil), "pb.RaftPeer")
	proto.RegisterType((*StepRequest)(nil), "pb.StepRequest")
	proto.RegisterType((*StepResponse)(nil), "pb.StepResponse")
	proto.RegisterType((*SubmitTransactionRequest)(nil), "pb.SubmitTransactionRequest")
	proto.RegisterType((*SubmitTransactionResponse)(nil), "pb.SubmitTransactionResponse")
}

func init() { proto.RegisterFile("pb/calvin.proto", fileDescriptor_afc31d04251e05fb) }

var fileDescriptor_afc31d04251e05fb = []byte{
	// 846 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xf6, 0x7a, 0xd7, 0x49, 0x7c, 0xd6, 0xc1, 0xee, 0x10, 0xca, 0xd4, 0x05, 0xc7, 0x5a, 0x2a,
	0xb4, 0x54, 0xc2, 0x09, 0xae, 0x90, 0x00, 0xa9, 0x17, 0x4e, 0x29, 0x68, 0x15, 0x93, 0x54, 0xb3,
	0x86, 0xf6, 0x02, 0xa9, 0x5a, 0x7b, 0x4f, 0x8d, 0x85, 0xed, 0x59, 0x66, 0xc6, 0xb4, 0xe1, 0x01,
	0xb8, 0xe1, 0x05, 0xb8, 0x84, 0x27, 0xe1, 0xb6, 0x97, 0x7d, 0x04, 0x1a, 0x6e, 0xfa, 0x18, 0x68,
	0x66, 0xec, 0x66, 0x1d, 0xdb, 0xa1, 0x12, 0x37, 0xf6, 0x9c, 0xef, 0x7c, 0x73, 0xf6, 0x3b, 0x7f,
	0xbb, 0x50, 0xcd, 0xfa, 0x07, 0x83, 0x64, 0xfc, 0xf3, 0x68, 0xda, 0xca, 0x04, 0x57, 0x9c, 0x14,
	0xb3, 0x7e, 0x7d, 0x6f, 0xc8, 0x87, 0xdc, 0x98, 0x07, 0xfa, 0x64, 0x3d, 0xf5, 0x0f, 0x87, 0xbc,
	0x85, 0x6a, 0x90, 0xb6, 0x46, 0xfc, 0x40, 0xff, 0x1f, 0x88, 0xe4, 0x89, 0x32, 0x3f, 0x59, 0xdf,
	0xfc, 0x59, 0x5e, 0xf0, 0x39, 0x54, 0xe3, 0xd1, 0x24, 0x1b, 0x63, 0x8c, 0x4a, 0xa1, 0xe8, 0x88,
	0x21, 0xa9, 0x81, 0x7b, 0x8c, 0x67, 0xd4, 0x69, 0x3a, 0x61, 0x85, 0xe9, 0x23, 0xd9, 0x83, 0xd2,
	0x77, 0xc9, 0x78, 0x86, 0xb4, 0x68, 0x30, 0x6b, 0x04, 0x77, 0xa1, 0x14, 0xa5, 0x9f, 0xb4, 0x3f,
	0xd3, 0xee, 0x6f, 0xb3, 0x0c, 0x85, 0xb9, 0xe2, 0x31, 0x6b, 0x68, 0xb4, 0xcb, 0x9f, 0xa2, 0x30,
	0x97, 0x3c, 0x66, 0x8d, 0x2f, 0x76, 0x5e, 0xfd, 0xb1, 0xef, 0xbc, 0xfa, 0x73, 0xdf, 0x09, 0xda,
	0xe0, 0x1f, 0x25, 0x12, 0xbf, 0x41, 0x29, 0x93, 0x21, 0x92, 0x0f, 0xc0, 0xeb, 0x9d, 0x65, 0x68,
	0x62, 0xbc, 0xd5, 0xae, 0xb6, 0xb2, 0x7e, 0x6b, 0xee, 0xd2, 0x30, 0x33, 0xce, 0xe0, 0x2f, 0x17,
	0xfc, 0x9e, 0x48, 0xa6, 0x32, 0x19, 0xa8, 0x11, 0x9f, 0xbe, 0xd1, 0x25, 0x72, 0x03, 0x8a, 0x51,
	0x6a, 0x54, 0xf8, 0xed, 0xb2, 0xa6, 0x18, 0xd5, 0xac, 0x18, 0xa5, 0x84, 0xc2, 0x36, 0xc3, 0x24,
	0x8d, 0x51, 0x51, 0xb7, 0xe9, 0x86, 0x15, 0xb6, 0x30, 0x49, 0x00, 0x15, 0x7d, 0x7c, 0x28, 0x46,
	0x4a, 0x97, 0x86, 0x7a, 0xc6, 0xbd, 0x84, 0x91, 0x26, 0xf8, 0xda, 0x46, 0x71, 0xc2, 0x53, 0x94,
	0xb4, 0xd4, 0x74, 0x43, 0x8f, 0xe5, 0x21, 0xcd, 0x30, 0xec, 0x39, 0x63, 0xcb, 0x32, 0x72, 0x10,
	0x09, 0xa1, 0x1a, 0x2b, 0x2e, 0x30, 0x7d, 0x20, 0xf8, 0x00, 0xd3, 0x99, 0x40, 0xba, 0xdd, 0x74,
	0xc2, 0x32, 0xbb, 0x0c, 0x93, 0x43, 0x78, 0xfb, 0x12, 0xd4, 0x11, 0x43, 0x49, 0x77, 0x8c, 0xb0,
	0x75, 0x2e, 0xd2, 0x02, 0x12, 0xc9, 0x2e, 0x7f, 0x1a, 0x49, 0x3e, 0x4e, 0x74, 0xbd, 0xb4, 0x34,
	0x5a, 0x6e, 0x3a, 0xe1, 0x0e, 0x5b, 0xe3, 0x21, 0x8f, 0x80, 0x5e, 0xc6, 0x18, 0xca, 0x8c, 0x4f,
	0x25, 0x52, 0x30, 0xe5, 0x7b, 0x4f, 0x97, 0x6f, 0x13, 0x87, 0x6d, 0xbc, 0x9d, 0xeb, 0xfa, 0x6f,
	0x0e, 0x80, 0xa5, 0x99, 0x47, 0xbe, 0x51, 0x03, 0xaf, 0xd2, 0x55, 0xfc, 0x3f, 0xba, 0x82, 0xaf,
	0xa1, 0x96, 0x1b, 0xa7, 0xa3, 0x44, 0x0d, 0x7e, 0x20, 0x77, 0xa0, 0xa2, 0x2e, 0x30, 0x49, 0x9d,
	0xa6, 0x1b, 0xfa, 0x56, 0x5a, 0x8e, 0xcb, 0x96, 0x48, 0xc1, 0xc7, 0xf0, 0xee, 0xea, 0x43, 0x7e,
	0x9a, 0xa1, 0x54, 0x84, 0x80, 0x77, 0x8c, 0x67, 0x36, 0x4e, 0x85, 0x99, 0x73, 0xf0, 0xcb, 0xe6,
	0x8c, 0xd6, 0xf1, 0xc9, 0x75, 0xd8, 0x32, 0x3b, 0x27, 0x69, 0xd1, 0xa0, 0x73, 0x4b, 0x73, 0x7b,
	0x28, 0x26, 0xd4, 0x35, 0x2b, 0x66, 0xce, 0x7a, 0xef, 0xa2, 0x69, 0x8a, 0xcf, 0xa8, 0x67, 0xf7,
	0xce, 0x18, 0xb9, 0x0e, 0xfc, 0xea, 0xc0, 0x35, 0x86, 0x13, 0xae, 0x30, 0xaf, 0x72, 0x1f, 0x4a,
	0xbd, 0x67, 0xd3, 0x28, 0x35, 0x9d, 0x58, 0xda, 0x13, 0x8b, 0xbf, 0x96, 0x55, 0x5c, 0x2b, 0xcb,
	0x5d, 0x92, 0x75, 0x0b, 0x76, 0x7b, 0x5c, 0x25, 0xe3, 0x93, 0xd9, 0xa4, 0xcb, 0x07, 0x3f, 0x4a,
	0x23, 0x65, 0x97, 0x2d, 0x83, 0xc1, 0x6d, 0x20, 0x79, 0x1d, 0xf3, 0xf4, 0xf7, 0xa0, 0x74, 0x5f,
	0x08, 0x6e, 0x5f, 0x26, 0x65, 0x66, 0x8d, 0xa0, 0x0b, 0x3b, 0x2c, 0x79, 0xa2, 0x1e, 0x20, 0x0a,
	0xd2, 0x00, 0xd0, 0x67, 0xbd, 0x3f, 0x73, 0xbd, 0x1e, 0xcb, 0x21, 0x7a, 0xe9, 0x34, 0xaf, 0x93,
	0xa6, 0x02, 0xa5, 0x34, 0x13, 0x52, 0x66, 0x79, 0x28, 0x78, 0x04, 0x7e, 0xac, 0x30, 0x5b, 0xe4,
	0xfe, 0x5f, 0x01, 0x3f, 0x82, 0xed, 0xf9, 0x50, 0xce, 0xc7, 0xad, 0xda, 0xb2, 0x2f, 0xd2, 0xc5,
	0xac, 0xb2, 0x85, 0x3f, 0xb8, 0x05, 0x15, 0x1b, 0xf9, 0xca, 0x6c, 0xea, 0x40, 0xe3, 0x59, 0x7f,
	0x32, 0x52, 0xf9, 0x81, 0xb2, 0x62, 0x82, 0x9b, 0x70, 0x63, 0x8d, 0xcf, 0x86, 0xbb, 0x7d, 0x08,
	0x7e, 0x6e, 0x3d, 0x48, 0x15, 0xfc, 0x1e, 0xeb, 0x9c, 0xc4, 0x9d, 0x7b, 0xbd, 0xe8, 0xf4, 0xa4,
	0x56, 0x20, 0x35, 0xa8, 0x74, 0x4f, 0x1f, 0x3e, 0x8e, 0xe2, 0xd3, 0xc7, 0xec, 0x7e, 0xe7, 0xcb,
	0x9a, 0xd3, 0x1e, 0x40, 0x6d, 0x65, 0xcf, 0x4f, 0xd7, 0x60, 0x37, 0xd7, 0x6f, 0x90, 0xd1, 0x54,
	0xbf, 0x72, 0xbd, 0x82, 0x42, 0xfb, 0x18, 0xe0, 0xa2, 0x93, 0xe4, 0xee, 0x92, 0xf5, 0x8e, 0xbe,
	0xbb, 0x32, 0x6f, 0xf5, 0xeb, 0x97, 0xe1, 0xd7, 0xc1, 0xbe, 0x82, 0x5d, 0x5d, 0x7b, 0x93, 0x7e,
	0xc6, 0x85, 0x22, 0x9f, 0x02, 0xe8, 0x9a, 0xc6, 0x4a, 0x60, 0x32, 0x21, 0x66, 0x11, 0x73, 0xdd,
	0xab, 0xd7, 0x2e, 0x80, 0x45, 0x8c, 0xd0, 0x39, 0x74, 0xda, 0xdf, 0xc3, 0xd6, 0x3d, 0xf3, 0xad,
	0x24, 0x0c, 0xae, 0xad, 0x94, 0x94, 0x98, 0x9c, 0x36, 0x75, 0xa1, 0xfe, 0xfe, 0x06, 0xef, 0xe2,
	0x09, 0x47, 0xf4, 0xf9, 0xcb, 0x46, 0xe1, 0xc5, 0xcb, 0x46, 0xe1, 0xf9, 0x79, 0xc3, 0x79, 0x71,
	0xde, 0x70, 0xfe, 0x3e, 0x6f, 0x38, 0xbf, 0xff, 0xd3, 0x28, 0xf4, 0xb7, 0xcc, 0x87, 0xf5, 0xce,
	0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb7, 0x26, 0x6d, 0x63, 0xad, 0x07, 0x00, 0x00,
}

func (this *Id128) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Upper != that1.Upper {
		if this.Upper < that1.Upper {
			return -1
		}
		return 1
	}
	if this.Lower != that1.Lower {
		if this.Lower < that1.Lower {
			return -1
		}
		return 1
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Transaction) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if this.Type != that1.Type {
		if this.Type < that1.Type {
			return -1
		}
		return 1
	}
	if c := this.Id.Compare(that1.Id); c != 0 {
		return c
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		if len(this.ReadSet) < len(that1.ReadSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadSet {
		if c := bytes.Compare(this.ReadSet[i], that1.ReadSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		if len(this.ReadWriteSet) < len(that1.ReadWriteSet) {
			return -1
		}
		return 1
	}
	for i := range this.ReadWriteSet {
		if c := bytes.Compare(this.ReadWriteSet[i], that1.ReadWriteSet[i]); c != 0 {
			return c
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		if len(this.ReaderNodes) < len(that1.ReaderNodes) {
			return -1
		}
		return 1
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			if this.ReaderNodes[i] < that1.ReaderNodes[i] {
				return -1
			}
			return 1
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		if len(this.WriterNodes) < len(that1.WriterNodes) {
			return -1
		}
		return 1
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			if this.WriterNodes[i] < that1.WriterNodes[i] {
				return -1
			}
			return 1
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		if this.StoredProcedure < that1.StoredProcedure {
			return -1
		}
		return 1
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		if len(this.StoredProcedureArgs) < len(that1.StoredProcedureArgs) {
			return -1
		}
		return 1
	}
	for i := range this.StoredProcedureArgs {
		if c := bytes.Compare(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]); c != 0 {
			return c
		}
	}
	if this.IsLowIsolationRead != that1.IsLowIsolationRead {
		if !this.IsLowIsolationRead {
			return -1
		}
		return 1
	}
	if c := this.LowIsolationReadResponse.Compare(that1.LowIsolationReadResponse); c != 0 {
		return c
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *LowIsolationReadResponse) Compare(that interface{}) int {
	if that == nil {
		if this == nil {
			return 0
		}
		return 1
	}

	that1, ok := that.(*LowIsolationReadResponse)
	if !ok {
		that2, ok := that.(LowIsolationReadResponse)
		if ok {
			that1 = &that2
		} else {
			return 1
		}
	}
	if that1 == nil {
		if this == nil {
			return 0
		}
		return 1
	} else if this == nil {
		return -1
	}
	if len(this.Keys) != len(that1.Keys) {
		if len(this.Keys) < len(that1.Keys) {
			return -1
		}
		return 1
	}
	for i := range this.Keys {
		if c := bytes.Compare(this.Keys[i], that1.Keys[i]); c != 0 {
			return c
		}
	}
	if len(this.Values) != len(that1.Values) {
		if len(this.Values) < len(that1.Values) {
			return -1
		}
		return 1
	}
	for i := range this.Values {
		if c := bytes.Compare(this.Values[i], that1.Values[i]); c != 0 {
			return c
		}
	}
	if this.Term != that1.Term {
		if this.Term < that1.Term {
			return -1
		}
		return 1
	}
	if this.Index != that1.Index {
		if this.Index < that1.Index {
			return -1
		}
		return 1
	}
	if c := bytes.Compare(this.XXX_unrecognized, that1.XXX_unrecognized); c != 0 {
		return c
	}
	return 0
}
func (this *Id128) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Id128)
	if !ok {
		that2, ok := that.(Id128)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Upper != that1.Upper {
		return false
	}
	if this.Lower != that1.Lower {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Transaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Transaction)
	if !ok {
		that2, ok := that.(Transaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.ReadSet) != len(that1.ReadSet) {
		return false
	}
	for i := range this.ReadSet {
		if !bytes.Equal(this.ReadSet[i], that1.ReadSet[i]) {
			return false
		}
	}
	if len(this.ReadWriteSet) != len(that1.ReadWriteSet) {
		return false
	}
	for i := range this.ReadWriteSet {
		if !bytes.Equal(this.ReadWriteSet[i], that1.ReadWriteSet[i]) {
			return false
		}
	}
	if len(this.ReaderNodes) != len(that1.ReaderNodes) {
		return false
	}
	for i := range this.ReaderNodes {
		if this.ReaderNodes[i] != that1.ReaderNodes[i] {
			return false
		}
	}
	if len(this.WriterNodes) != len(that1.WriterNodes) {
		return false
	}
	for i := range this.WriterNodes {
		if this.WriterNodes[i] != that1.WriterNodes[i] {
			return false
		}
	}
	if this.StoredProcedure != that1.StoredProcedure {
		return false
	}
	if len(this.StoredProcedureArgs) != len(that1.StoredProcedureArgs) {
		return false
	}
	for i := range this.StoredProcedureArgs {
		if !bytes.Equal(this.StoredProcedureArgs[i], that1.StoredProcedureArgs[i]) {
			return false
		}
	}
	if this.IsLowIsolationRead != that1.IsLowIsolationRead {
		return false
	}
	if !this.LowIsolationReadResponse.Equal(that1.LowIsolationReadResponse) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LowIsolationReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LowIsolationReadResponse)
	if !ok {
		that2, ok := that.(LowIsolationReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return false
		}
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !bytes.Equal(this.Values[i], that1.Values[i]) {
			return false
		}
	}
	if this.Term != that1.Term {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LowIsolationReadClient is the client API for LowIsolationRead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LowIsolationReadClient interface {
	LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error)
}

type lowIsolationReadClient struct {
	cc *grpc.ClientConn
}

func NewLowIsolationReadClient(cc *grpc.ClientConn) LowIsolationReadClient {
	return &lowIsolationReadClient{cc}
}

func (c *lowIsolationReadClient) LowIsolationRead(ctx context.Context, in *LowIsolationReadRequest, opts ...grpc.CallOption) (*LowIsolationReadResponse, error) {
	out := new(LowIsolationReadResponse)
	err := c.cc.Invoke(ctx, "/pb.LowIsolationRead/LowIsolationRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LowIsolationReadServer is the server API for LowIsolationRead service.
type LowIsolationReadServer interface {
	LowIsolationRead(context.Context, *LowIsolationReadRequest) (*LowIsolationReadResponse, error)
}

func RegisterLowIsolationReadServer(s *grpc.Server, srv LowIsolationReadServer) {
	s.RegisterService(&_LowIsolationRead_serviceDesc, srv)
}

func _LowIsolationRead_LowIsolationRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LowIsolationReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LowIsolationReadServer).LowIsolationRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.LowIsolationRead/LowIsolationRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LowIsolationReadServer).LowIsolationRead(ctx, req.(*LowIsolationReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LowIsolationRead_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.LowIsolationRead",
	HandlerType: (*LowIsolationReadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LowIsolationRead",
			Handler:    _LowIsolationRead_LowIsolationRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

// RemoteReadClient is the client API for RemoteRead service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RemoteReadClient interface {
	RemoteRead(ctx context.Context, in *RemoteReadRequest, opts ...grpc.CallOption) (*RemoteReadResponse, error)
}

type remoteReadClient struct {
	cc *grpc.ClientConn
}

func NewRemoteReadClient(cc *grpc.ClientConn) RemoteReadClient {
	return &remoteReadClient{cc}
}

func (c *remoteReadClient) RemoteRead(ctx context.Context, in *RemoteReadRequest, opts ...grpc.CallOption) (*RemoteReadResponse, error) {
	out := new(RemoteReadResponse)
	err := c.cc.Invoke(ctx, "/pb.RemoteRead/RemoteRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RemoteReadServer is the server API for RemoteRead service.
type RemoteReadServer interface {
	RemoteRead(context.Context, *RemoteReadRequest) (*RemoteReadResponse, error)
}

func RegisterRemoteReadServer(s *grpc.Server, srv RemoteReadServer) {
	s.RegisterService(&_RemoteRead_serviceDesc, srv)
}

func _RemoteRead_RemoteRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoteReadServer).RemoteRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RemoteRead/RemoteRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoteReadServer).RemoteRead(ctx, req.(*RemoteReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RemoteRead_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RemoteRead",
	HandlerType: (*RemoteReadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoteRead",
			Handler:    _RemoteRead_RemoteRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

// RaftTransportClient is the client API for RaftTransport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftTransportClient interface {
	StepStream(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_StepStreamClient, error)
}

type raftTransportClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportClient(cc *grpc.ClientConn) RaftTransportClient {
	return &raftTransportClient{cc}
}

func (c *raftTransportClient) StepStream(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_StepStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftTransport_serviceDesc.Streams[0], "/pb.RaftTransport/StepStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportStepStreamClient{stream}
	return x, nil
}

type RaftTransport_StepStreamClient interface {
	Send(*StepRequest) error
	Recv() (*StepResponse, error)
	grpc.ClientStream
}

type raftTransportStepStreamClient struct {
	grpc.ClientStream
}

func (x *raftTransportStepStreamClient) Send(m *StepRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportStepStreamClient) Recv() (*StepResponse, error) {
	m := new(StepResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftTransportServer is the server API for RaftTransport service.
type RaftTransportServer interface {
	StepStream(RaftTransport_StepStreamServer) error
}

func RegisterRaftTransportServer(s *grpc.Server, srv RaftTransportServer) {
	s.RegisterService(&_RaftTransport_serviceDesc, srv)
}

func _RaftTransport_StepStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServer).StepStream(&raftTransportStepStreamServer{stream})
}

type RaftTransport_StepStreamServer interface {
	Send(*StepResponse) error
	Recv() (*StepRequest, error)
	grpc.ServerStream
}

type raftTransportStepStreamServer struct {
	grpc.ServerStream
}

func (x *raftTransportStepStreamServer) Send(m *StepResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportStepStreamServer) Recv() (*StepRequest, error) {
	m := new(StepRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftTransport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftTransport",
	HandlerType: (*RaftTransportServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StepStream",
			Handler:       _RaftTransport_StepStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/calvin.proto",
}

// CalvinClient is the client API for Calvin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CalvinClient interface {
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
}

type calvinClient struct {
	cc *grpc.ClientConn
}

func NewCalvinClient(cc *grpc.ClientConn) CalvinClient {
	return &calvinClient{cc}
}

func (c *calvinClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.Calvin/SubmitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalvinServer is the server API for Calvin service.
type CalvinServer interface {
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
}

func RegisterCalvinServer(s *grpc.Server, srv CalvinServer) {
	s.RegisterService(&_Calvin_serviceDesc, srv)
}

func _Calvin_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalvinServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Calvin/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalvinServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Calvin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Calvin",
	HandlerType: (*CalvinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitTransaction",
			Handler:    _Calvin_SubmitTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/calvin.proto",
}

func (m *SimpleSetterArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleSetterArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Id128) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id128) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upper != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Upper))
	}
	if m.Lower != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BaseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Type))
	}
	if m.Id != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Id.Size()))
		n1, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ReaderNodes) > 0 {
		dAtA3 := make([]byte, len(m.ReaderNodes)*10)
		var j2 int
		for _, num := range m.ReaderNodes {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.WriterNodes) > 0 {
		dAtA5 := make([]byte, len(m.WriterNodes)*10)
		var j4 int
		for _, num := range m.WriterNodes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.StoredProcedure) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.StoredProcedure)))
		i += copy(dAtA[i:], m.StoredProcedure)
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.IsLowIsolationRead {
		dAtA[i] = 0x48
		i++
		if m.IsLowIsolationRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LowIsolationReadResponse != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.LowIsolationReadResponse.Size()))
		n6, err := m.LowIsolationReadResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsoRead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsoRead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Type))
	}
	if m.LowIsolationReadResponse != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.LowIsolationReadResponse.Size()))
		n7, err := m.LowIsolationReadResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LowIsolationReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LowIsolationReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Term))
	}
	if m.Index != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.TxnId.Size()))
		n8, err := m.TxnId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCalvin(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.TotalNumLocks != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.TotalNumLocks))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.RaftNodeId))
	}
	if len(m.PeerAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.PeerAddress)))
		i += copy(dAtA[i:], m.PeerAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(m.Message.Size()))
		n9, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StepResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCalvin(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmitTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmitTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCalvin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SimpleSetterArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Id128) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Upper != 0 {
		n += 1 + sovCalvin(uint64(m.Upper))
	}
	if m.Lower != 0 {
		n += 1 + sovCalvin(uint64(m.Lower))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCalvin(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCalvin(uint64(m.Type))
	}
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.ReadSet) > 0 {
		for _, b := range m.ReadSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReadWriteSet) > 0 {
		for _, b := range m.ReadWriteSet {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.ReaderNodes) > 0 {
		l = 0
		for _, e := range m.ReaderNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	if len(m.WriterNodes) > 0 {
		l = 0
		for _, e := range m.WriterNodes {
			l += sovCalvin(uint64(e))
		}
		n += 1 + sovCalvin(uint64(l)) + l
	}
	l = len(m.StoredProcedure)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.StoredProcedureArgs) > 0 {
		for _, b := range m.StoredProcedureArgs {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.IsLowIsolationRead {
		n += 2
	}
	if m.LowIsolationReadResponse != nil {
		l = m.LowIsolationReadResponse.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsoRead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCalvin(uint64(m.Type))
	}
	if m.LowIsolationReadResponse != nil {
		l = m.LowIsolationReadResponse.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LowIsolationReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.Term != 0 {
		n += 1 + sovCalvin(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovCalvin(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnId != nil {
		l = m.TxnId.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCalvin(uint64(l))
		}
	}
	if m.TotalNumLocks != 0 {
		n += 1 + sovCalvin(uint64(m.TotalNumLocks))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		n += 1 + sovCalvin(uint64(m.RaftNodeId))
	}
	l = len(m.PeerAddress)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftNodeId != 0 {
		n += 1 + sovCalvin(uint64(m.RaftNodeId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCalvin(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCalvin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCalvin(x uint64) (n int) {
	return sovCalvin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SimpleSetterArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleSetterArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleSetterArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &Id128{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadSet = append(m.ReadSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadSet[len(m.ReadSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWriteSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadWriteSet = append(m.ReadWriteSet, make([]byte, postIndex-iNdEx))
			copy(m.ReadWriteSet[len(m.ReadWriteSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReaderNodes = append(m.ReaderNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReaderNodes) == 0 {
					m.ReaderNodes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReaderNodes = append(m.ReaderNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderNodes", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WriterNodes = append(m.WriterNodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCalvin
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCalvin
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WriterNodes) == 0 {
					m.WriterNodes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCalvin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WriterNodes = append(m.WriterNodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WriterNodes", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoredProcedureArgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoredProcedureArgs = append(m.StoredProcedureArgs, make([]byte, postIndex-iNdEx))
			copy(m.StoredProcedureArgs[len(m.StoredProcedureArgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLowIsolationRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLowIsolationRead = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIsolationReadResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowIsolationReadResponse == nil {
				m.LowIsolationReadResponse = &LowIsolationReadResponse{}
			}
			if err := m.LowIsolationReadResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsoRead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsoRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsoRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIsolationReadResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowIsolationReadResponse == nil {
				m.LowIsolationReadResponse = &LowIsolationReadResponse{}
			}
			if err := m.LowIsolationReadResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LowIsolationReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LowIsolationReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LowIsolationReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnId == nil {
				m.TxnId = &Id128{}
			}
			if err := m.TxnId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNumLocks", wireType)
			}
			m.TotalNumLocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNumLocks |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeId", wireType)
			}
			m.RaftNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftNodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeId", wireType)
			}
			m.RaftNodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftNodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &raftpb.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCalvin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCalvin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCalvin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCalvin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCalvin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCalvin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCalvin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCalvin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCalvin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCalvin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCalvin
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCalvin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCalvin   = fmt.Errorf("proto: integer overflow")
)
