// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tpcc/pb/tpcc.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Warehouse struct {
	// A warehouse has only one primary key
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The following are informational fields as defined in TPC-C standard
	Name     string `protobuf:"bytes,11,opt,name=name,proto3" json:"name,omitempty"`
	Street_1 string `protobuf:"bytes,12,opt,name=street_1,json=street1,proto3" json:"street_1,omitempty"`
	Street_2 string `protobuf:"bytes,13,opt,name=street_2,json=street2,proto3" json:"street_2,omitempty"`
	City     string `protobuf:"bytes,14,opt,name=city,proto3" json:"city,omitempty"`
	State    string `protobuf:"bytes,15,opt,name=state,proto3" json:"state,omitempty"`
	Zip      string `protobuf:"bytes,16,opt,name=zip,proto3" json:"zip,omitempty"`
	// The following are income records as specified in TPC-C standard
	Tax                  float64  `protobuf:"fixed64,20,opt,name=tax,proto3" json:"tax,omitempty"`
	YearToDate           float64  `protobuf:"fixed64,21,opt,name=year_to_date,json=yearToDate,proto3" json:"year_to_date,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Warehouse) Reset()         { *m = Warehouse{} }
func (m *Warehouse) String() string { return proto.CompactTextString(m) }
func (*Warehouse) ProtoMessage()    {}
func (*Warehouse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{0}
}
func (m *Warehouse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Warehouse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Warehouse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Warehouse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Warehouse.Merge(m, src)
}
func (m *Warehouse) XXX_Size() int {
	return m.Size()
}
func (m *Warehouse) XXX_DiscardUnknown() {
	xxx_messageInfo_Warehouse.DiscardUnknown(m)
}

var xxx_messageInfo_Warehouse proto.InternalMessageInfo

func (m *Warehouse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Warehouse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Warehouse) GetStreet_1() string {
	if m != nil {
		return m.Street_1
	}
	return ""
}

func (m *Warehouse) GetStreet_2() string {
	if m != nil {
		return m.Street_2
	}
	return ""
}

func (m *Warehouse) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *Warehouse) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Warehouse) GetZip() string {
	if m != nil {
		return m.Zip
	}
	return ""
}

func (m *Warehouse) GetTax() float64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *Warehouse) GetYearToDate() float64 {
	if m != nil {
		return m.YearToDate
	}
	return 0
}

type District struct {
	// A district has one primary key and one parent (foreign) key for the
	// warehouse it belongs to
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	WarehouseId string `protobuf:"bytes,2,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	// The following are informational fields for a district as defined by the
	// TPC-C standards
	Name     string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	Street_1 string `protobuf:"bytes,11,opt,name=street_1,json=street1,proto3" json:"street_1,omitempty"`
	Street_2 string `protobuf:"bytes,12,opt,name=street_2,json=street2,proto3" json:"street_2,omitempty"`
	City     string `protobuf:"bytes,13,opt,name=city,proto3" json:"city,omitempty"`
	State    string `protobuf:"bytes,14,opt,name=state,proto3" json:"state,omitempty"`
	Zip      string `protobuf:"bytes,15,opt,name=zip,proto3" json:"zip,omitempty"`
	// The following are income records as specified in the TPC-C standard
	Tax                  float64  `protobuf:"fixed64,20,opt,name=tax,proto3" json:"tax,omitempty"`
	YearToDate           float64  `protobuf:"fixed64,21,opt,name=year_to_date,json=yearToDate,proto3" json:"year_to_date,omitempty"`
	NextOrderId          int32    `protobuf:"varint,22,opt,name=next_order_id,json=nextOrderId,proto3" json:"next_order_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *District) Reset()         { *m = District{} }
func (m *District) String() string { return proto.CompactTextString(m) }
func (*District) ProtoMessage()    {}
func (*District) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{1}
}
func (m *District) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *District) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_District.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *District) XXX_Merge(src proto.Message) {
	xxx_messageInfo_District.Merge(m, src)
}
func (m *District) XXX_Size() int {
	return m.Size()
}
func (m *District) XXX_DiscardUnknown() {
	xxx_messageInfo_District.DiscardUnknown(m)
}

var xxx_messageInfo_District proto.InternalMessageInfo

func (m *District) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *District) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *District) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *District) GetStreet_1() string {
	if m != nil {
		return m.Street_1
	}
	return ""
}

func (m *District) GetStreet_2() string {
	if m != nil {
		return m.Street_2
	}
	return ""
}

func (m *District) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *District) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *District) GetZip() string {
	if m != nil {
		return m.Zip
	}
	return ""
}

func (m *District) GetTax() float64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *District) GetYearToDate() float64 {
	if m != nil {
		return m.YearToDate
	}
	return 0
}

func (m *District) GetNextOrderId() int32 {
	if m != nil {
		return m.NextOrderId
	}
	return 0
}

type Customer struct {
	// A customer has one primary key, one parent (foreign) key for the district
	// it belongs to and one grandparent (foreign) key for the warehouse the
	// district it is in belongs to
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DistrictId  string `protobuf:"bytes,2,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	WarehouseId string `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	// The following are informational fields for a customer as defined by the
	// TPC-C standards
	First    string `protobuf:"bytes,10,opt,name=first,proto3" json:"first,omitempty"`
	Middle   string `protobuf:"bytes,11,opt,name=middle,proto3" json:"middle,omitempty"`
	Last     string `protobuf:"bytes,12,opt,name=last,proto3" json:"last,omitempty"`
	Street_1 string `protobuf:"bytes,13,opt,name=street_1,json=street1,proto3" json:"street_1,omitempty"`
	Street_2 string `protobuf:"bytes,14,opt,name=street_2,json=street2,proto3" json:"street_2,omitempty"`
	City     string `protobuf:"bytes,15,opt,name=city,proto3" json:"city,omitempty"`
	State    string `protobuf:"bytes,16,opt,name=state,proto3" json:"state,omitempty"`
	Zip      string `protobuf:"bytes,17,opt,name=zip,proto3" json:"zip,omitempty"`
	// The following are income records as specified in the TPC-C standard
	Since             int32   `protobuf:"varint,20,opt,name=since,proto3" json:"since,omitempty"`
	Credit            string  `protobuf:"bytes,21,opt,name=credit,proto3" json:"credit,omitempty"`
	CreditLimit       float64 `protobuf:"fixed64,22,opt,name=credit_limit,json=creditLimit,proto3" json:"credit_limit,omitempty"`
	Discount          float64 `protobuf:"fixed64,23,opt,name=discount,proto3" json:"discount,omitempty"`
	Balance           float64 `protobuf:"fixed64,24,opt,name=balance,proto3" json:"balance,omitempty"`
	YearToDatePayment float64 `protobuf:"fixed64,25,opt,name=year_to_date_payment,json=yearToDatePayment,proto3" json:"year_to_date_payment,omitempty"`
	PaymentCount      int32   `protobuf:"varint,26,opt,name=payment_count,json=paymentCount,proto3" json:"payment_count,omitempty"`
	DeliveryCount     int32   `protobuf:"varint,27,opt,name=delivery_count,json=deliveryCount,proto3" json:"delivery_count,omitempty"`
	// The following is an data field for entering miscellany
	Data                 []byte   `protobuf:"bytes,30,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Customer) Reset()         { *m = Customer{} }
func (m *Customer) String() string { return proto.CompactTextString(m) }
func (*Customer) ProtoMessage()    {}
func (*Customer) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{2}
}
func (m *Customer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Customer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Customer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Customer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Customer.Merge(m, src)
}
func (m *Customer) XXX_Size() int {
	return m.Size()
}
func (m *Customer) XXX_DiscardUnknown() {
	xxx_messageInfo_Customer.DiscardUnknown(m)
}

var xxx_messageInfo_Customer proto.InternalMessageInfo

func (m *Customer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Customer) GetDistrictId() string {
	if m != nil {
		return m.DistrictId
	}
	return ""
}

func (m *Customer) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *Customer) GetFirst() string {
	if m != nil {
		return m.First
	}
	return ""
}

func (m *Customer) GetMiddle() string {
	if m != nil {
		return m.Middle
	}
	return ""
}

func (m *Customer) GetLast() string {
	if m != nil {
		return m.Last
	}
	return ""
}

func (m *Customer) GetStreet_1() string {
	if m != nil {
		return m.Street_1
	}
	return ""
}

func (m *Customer) GetStreet_2() string {
	if m != nil {
		return m.Street_2
	}
	return ""
}

func (m *Customer) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *Customer) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Customer) GetZip() string {
	if m != nil {
		return m.Zip
	}
	return ""
}

func (m *Customer) GetSince() int32 {
	if m != nil {
		return m.Since
	}
	return 0
}

func (m *Customer) GetCredit() string {
	if m != nil {
		return m.Credit
	}
	return ""
}

func (m *Customer) GetCreditLimit() float64 {
	if m != nil {
		return m.CreditLimit
	}
	return 0
}

func (m *Customer) GetDiscount() float64 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *Customer) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Customer) GetYearToDatePayment() float64 {
	if m != nil {
		return m.YearToDatePayment
	}
	return 0
}

func (m *Customer) GetPaymentCount() int32 {
	if m != nil {
		return m.PaymentCount
	}
	return 0
}

func (m *Customer) GetDeliveryCount() int32 {
	if m != nil {
		return m.DeliveryCount
	}
	return 0
}

func (m *Customer) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type NewOrder struct {
	// A new order has one primary key, one parent (foreign) key for the district
	// it originated in, and one grandparent (foreign) key for the warehouse
	// the district it originated in belongs to
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DistrictId           string   `protobuf:"bytes,2,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	WarehouseId          string   `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewOrder) Reset()         { *m = NewOrder{} }
func (m *NewOrder) String() string { return proto.CompactTextString(m) }
func (*NewOrder) ProtoMessage()    {}
func (*NewOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{3}
}
func (m *NewOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewOrder.Merge(m, src)
}
func (m *NewOrder) XXX_Size() int {
	return m.Size()
}
func (m *NewOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_NewOrder.DiscardUnknown(m)
}

var xxx_messageInfo_NewOrder proto.InternalMessageInfo

func (m *NewOrder) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NewOrder) GetDistrictId() string {
	if m != nil {
		return m.DistrictId
	}
	return ""
}

func (m *NewOrder) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

type Order struct {
	// An order has one primary key, one parent (foreign) key for the customer
	// that originated the order, one grandparent (foreign) key for the district
	// that customer is in, and one grandparent (foreign) key for the district's
	// warehouse
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DistrictId  string `protobuf:"bytes,2,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	WarehouseId string `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	CustomerId  string `protobuf:"bytes,4,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The following are informational fields for an order as defined by the
	// TPC-C standards
	EntryDate      float64 `protobuf:"fixed64,10,opt,name=entry_date,json=entryDate,proto3" json:"entry_date,omitempty"`
	CarrierId      int32   `protobuf:"varint,11,opt,name=carrier_id,json=carrierId,proto3" json:"carrier_id,omitempty"`
	OrderLineCount int32   `protobuf:"varint,12,opt,name=order_line_count,json=orderLineCount,proto3" json:"order_line_count,omitempty"`
	AllItemsLocal  bool    `protobuf:"varint,13,opt,name=all_items_local,json=allItemsLocal,proto3" json:"all_items_local,omitempty"`
	// Embedding OrderLines into Order (by reference). Kind of hackish. (Alex)
	OrderLinePtr         []uint64 `protobuf:"varint,14,rep,packed,name=order_line_ptr,json=orderLinePtr,proto3" json:"order_line_ptr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{4}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetDistrictId() string {
	if m != nil {
		return m.DistrictId
	}
	return ""
}

func (m *Order) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *Order) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *Order) GetEntryDate() float64 {
	if m != nil {
		return m.EntryDate
	}
	return 0
}

func (m *Order) GetCarrierId() int32 {
	if m != nil {
		return m.CarrierId
	}
	return 0
}

func (m *Order) GetOrderLineCount() int32 {
	if m != nil {
		return m.OrderLineCount
	}
	return 0
}

func (m *Order) GetAllItemsLocal() bool {
	if m != nil {
		return m.AllItemsLocal
	}
	return false
}

func (m *Order) GetOrderLinePtr() []uint64 {
	if m != nil {
		return m.OrderLinePtr
	}
	return nil
}

type OrderLine struct {
	// An order line has a foreign key for the order it belongs to, the district
	// the order line occurs in, the warehouse that district belongs to,
	// which item is being ordered and which supply warehouse it is being
	// taken from
	OrderId           string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	DistrictId        string `protobuf:"bytes,2,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	WarehouseId       string `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	ItemId            string `protobuf:"bytes,4,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	SupplyWarehouseId string `protobuf:"bytes,5,opt,name=supply_warehouse_id,json=supplyWarehouseId,proto3" json:"supply_warehouse_id,omitempty"`
	// The following are informational fields for an orderline as defined by the
	// TPC-C standards
	Number               int32    `protobuf:"varint,10,opt,name=number,proto3" json:"number,omitempty"`
	DeliveryDate         float64  `protobuf:"fixed64,11,opt,name=delivery_date,json=deliveryDate,proto3" json:"delivery_date,omitempty"`
	Quantity             int32    `protobuf:"varint,12,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Amount               float64  `protobuf:"fixed64,13,opt,name=amount,proto3" json:"amount,omitempty"`
	DistrictInformation  []byte   `protobuf:"bytes,14,opt,name=district_information,json=districtInformation,proto3" json:"district_information,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderLine) Reset()         { *m = OrderLine{} }
func (m *OrderLine) String() string { return proto.CompactTextString(m) }
func (*OrderLine) ProtoMessage()    {}
func (*OrderLine) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{5}
}
func (m *OrderLine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderLine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderLine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderLine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderLine.Merge(m, src)
}
func (m *OrderLine) XXX_Size() int {
	return m.Size()
}
func (m *OrderLine) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderLine.DiscardUnknown(m)
}

var xxx_messageInfo_OrderLine proto.InternalMessageInfo

func (m *OrderLine) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderLine) GetDistrictId() string {
	if m != nil {
		return m.DistrictId
	}
	return ""
}

func (m *OrderLine) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *OrderLine) GetItemId() string {
	if m != nil {
		return m.ItemId
	}
	return ""
}

func (m *OrderLine) GetSupplyWarehouseId() string {
	if m != nil {
		return m.SupplyWarehouseId
	}
	return ""
}

func (m *OrderLine) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *OrderLine) GetDeliveryDate() float64 {
	if m != nil {
		return m.DeliveryDate
	}
	return 0
}

func (m *OrderLine) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *OrderLine) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *OrderLine) GetDistrictInformation() []byte {
	if m != nil {
		return m.DistrictInformation
	}
	return nil
}

type Item struct {
	// An item has only one primary key
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The following are informational fields for an item as defined by the
	// TPC-C standards
	Name  string  `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	Price float64 `protobuf:"fixed64,11,opt,name=price,proto3" json:"price,omitempty"`
	// The following is an data field for entering miscellany
	Data                 []byte   `protobuf:"bytes,20,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{6}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Item) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Item) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Item) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Stock struct {
	// A stock has one primary key (the item it represents) and one
	// foreign key (the warehouse it is in)
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ItemId      string `protobuf:"bytes,2,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	WarehouseId string `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	// The following are informational fields for a stock as defined by the
	// TPC-C standards
	Quantity    int32    `protobuf:"varint,10,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Districts   [][]byte `protobuf:"bytes,11,rep,name=districts,proto3" json:"districts,omitempty"`
	YearToDate  int32    `protobuf:"varint,12,opt,name=year_to_date,json=yearToDate,proto3" json:"year_to_date,omitempty"`
	OrderCount  int32    `protobuf:"varint,13,opt,name=order_count,json=orderCount,proto3" json:"order_count,omitempty"`
	RemoteCount int32    `protobuf:"varint,14,opt,name=remote_count,json=remoteCount,proto3" json:"remote_count,omitempty"`
	// The following is an data field for entering miscellany
	Data                 []byte   `protobuf:"bytes,20,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Stock) Reset()         { *m = Stock{} }
func (m *Stock) String() string { return proto.CompactTextString(m) }
func (*Stock) ProtoMessage()    {}
func (*Stock) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{7}
}
func (m *Stock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stock.Merge(m, src)
}
func (m *Stock) XXX_Size() int {
	return m.Size()
}
func (m *Stock) XXX_DiscardUnknown() {
	xxx_messageInfo_Stock.DiscardUnknown(m)
}

var xxx_messageInfo_Stock proto.InternalMessageInfo

func (m *Stock) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Stock) GetItemId() string {
	if m != nil {
		return m.ItemId
	}
	return ""
}

func (m *Stock) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *Stock) GetQuantity() int32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Stock) GetDistricts() [][]byte {
	if m != nil {
		return m.Districts
	}
	return nil
}

func (m *Stock) GetYearToDate() int32 {
	if m != nil {
		return m.YearToDate
	}
	return 0
}

func (m *Stock) GetOrderCount() int32 {
	if m != nil {
		return m.OrderCount
	}
	return 0
}

func (m *Stock) GetRemoteCount() int32 {
	if m != nil {
		return m.RemoteCount
	}
	return 0
}

func (m *Stock) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type History struct {
	// A history object contains keys for the customer that originated the
	// item, which district and warehouse it was in, and which district and
	// warehouse the customer belonged to
	CustomerId          string `protobuf:"bytes,1,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	DistrictId          string `protobuf:"bytes,2,opt,name=district_id,json=districtId,proto3" json:"district_id,omitempty"`
	WarehouseId         string `protobuf:"bytes,3,opt,name=warehouse_id,json=warehouseId,proto3" json:"warehouse_id,omitempty"`
	CustomerDistrictId  string `protobuf:"bytes,4,opt,name=customer_district_id,json=customerDistrictId,proto3" json:"customer_district_id,omitempty"`
	CustomerWarehouseId string `protobuf:"bytes,5,opt,name=customer_warehouse_id,json=customerWarehouseId,proto3" json:"customer_warehouse_id,omitempty"`
	// The following are informational fields for a history as defined by the
	// TPC-C standards
	Date   float64 `protobuf:"fixed64,10,opt,name=date,proto3" json:"date,omitempty"`
	Amount float64 `protobuf:"fixed64,11,opt,name=amount,proto3" json:"amount,omitempty"`
	// The following is an data field for entering miscellany
	Data                 []byte   `protobuf:"bytes,20,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *History) Reset()         { *m = History{} }
func (m *History) String() string { return proto.CompactTextString(m) }
func (*History) ProtoMessage()    {}
func (*History) Descriptor() ([]byte, []int) {
	return fileDescriptor_2371128e9847d71d, []int{8}
}
func (m *History) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *History) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_History.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *History) XXX_Merge(src proto.Message) {
	xxx_messageInfo_History.Merge(m, src)
}
func (m *History) XXX_Size() int {
	return m.Size()
}
func (m *History) XXX_DiscardUnknown() {
	xxx_messageInfo_History.DiscardUnknown(m)
}

var xxx_messageInfo_History proto.InternalMessageInfo

func (m *History) GetCustomerId() string {
	if m != nil {
		return m.CustomerId
	}
	return ""
}

func (m *History) GetDistrictId() string {
	if m != nil {
		return m.DistrictId
	}
	return ""
}

func (m *History) GetWarehouseId() string {
	if m != nil {
		return m.WarehouseId
	}
	return ""
}

func (m *History) GetCustomerDistrictId() string {
	if m != nil {
		return m.CustomerDistrictId
	}
	return ""
}

func (m *History) GetCustomerWarehouseId() string {
	if m != nil {
		return m.CustomerWarehouseId
	}
	return ""
}

func (m *History) GetDate() float64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *History) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *History) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Warehouse)(nil), "pb.Warehouse")
	proto.RegisterType((*District)(nil), "pb.District")
	proto.RegisterType((*Customer)(nil), "pb.Customer")
	proto.RegisterType((*NewOrder)(nil), "pb.NewOrder")
	proto.RegisterType((*Order)(nil), "pb.Order")
	proto.RegisterType((*OrderLine)(nil), "pb.OrderLine")
	proto.RegisterType((*Item)(nil), "pb.Item")
	proto.RegisterType((*Stock)(nil), "pb.Stock")
	proto.RegisterType((*History)(nil), "pb.History")
}

func init() { proto.RegisterFile("tpcc/pb/tpcc.proto", fileDescriptor_2371128e9847d71d) }

var fileDescriptor_2371128e9847d71d = []byte{
	// 922 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xc7, 0x99, 0x59, 0xcf, 0xda, 0xae, 0x19, 0xcf, 0x7a, 0x7b, 0x9d, 0xcd, 0x64, 0x21, 0x8e,
	0x63, 0x3e, 0xe4, 0x53, 0x96, 0x5d, 0xde, 0x80, 0xec, 0x01, 0x4b, 0x2b, 0x12, 0x0d, 0x91, 0xf6,
	0xc6, 0xa8, 0x3d, 0xdd, 0x11, 0x2d, 0xe6, 0x8b, 0x9e, 0x36, 0x89, 0x79, 0x01, 0x5e, 0x80, 0x03,
	0x12, 0x6f, 0xc0, 0x91, 0xa7, 0xe0, 0xc8, 0x05, 0x71, 0x45, 0xcb, 0x8b, 0xa0, 0xae, 0x9e, 0x2f,
	0xc7, 0x5e, 0x09, 0x89, 0xe4, 0xe4, 0xae, 0x7f, 0xd5, 0xd4, 0x74, 0xfd, 0xba, 0x6a, 0xda, 0x40,
	0x54, 0x11, 0xc7, 0xe7, 0xc5, 0xea, 0x5c, 0xff, 0x3e, 0x29, 0x64, 0xae, 0x72, 0x62, 0x17, 0xab,
	0xf9, 0x9f, 0x16, 0x0c, 0x6f, 0xa8, 0xe4, 0xdf, 0xe4, 0xeb, 0x92, 0x13, 0x1f, 0x6c, 0xc1, 0x02,
	0x6b, 0x66, 0x2d, 0x86, 0xa1, 0x2d, 0x18, 0x21, 0xd0, 0xcb, 0x68, 0xca, 0x03, 0x17, 0x15, 0x5c,
	0x93, 0x07, 0x30, 0x28, 0x95, 0xe4, 0x5c, 0x45, 0x17, 0x81, 0x87, 0x7a, 0xdf, 0xd8, 0x17, 0x1d,
	0xd7, 0x65, 0x30, 0xea, 0xba, 0x2e, 0x75, 0xa6, 0x58, 0xa8, 0x4d, 0xe0, 0x9b, 0x4c, 0x7a, 0x4d,
	0x26, 0xe0, 0x94, 0x8a, 0x2a, 0x1e, 0x1c, 0xa1, 0x68, 0x0c, 0x32, 0x86, 0x83, 0x1f, 0x44, 0x11,
	0x8c, 0x51, 0xd3, 0x4b, 0xad, 0x28, 0xfa, 0x3a, 0x98, 0xcc, 0xac, 0x85, 0x15, 0xea, 0x25, 0x99,
	0x81, 0xb7, 0xe1, 0x54, 0x46, 0x2a, 0x8f, 0x98, 0x4e, 0x70, 0x0f, 0x5d, 0xa0, 0xb5, 0x17, 0xf9,
	0x15, 0x55, 0x7c, 0xfe, 0x8b, 0x0d, 0x83, 0x2b, 0x51, 0x2a, 0x29, 0x62, 0xb5, 0x53, 0xd6, 0x63,
	0xf0, 0x5e, 0xd5, 0x35, 0x47, 0x82, 0x05, 0x36, 0x7a, 0xdc, 0x46, 0x5b, 0xb6, 0x95, 0xc3, 0x1d,
	0x95, 0xbb, 0x77, 0x57, 0xee, 0xed, 0xaf, 0x7c, 0xb4, 0xaf, 0x72, 0x7f, 0x4f, 0xe5, 0x47, 0xff,
	0xab, 0x72, 0x32, 0x87, 0x51, 0xc6, 0x5f, 0xab, 0x28, 0x97, 0x8c, 0x4b, 0x5d, 0xdd, 0xe9, 0xcc,
	0x5a, 0x38, 0xa1, 0xab, 0xc5, 0x67, 0x5a, 0x5b, 0xb2, 0xf9, 0xaf, 0x3d, 0x18, 0x3c, 0x5d, 0x97,
	0x2a, 0x4f, 0xb9, 0xdc, 0xa1, 0xf3, 0x08, 0x5c, 0x56, 0x91, 0x6b, 0xe1, 0x40, 0x2d, 0x2d, 0x77,
	0xf1, 0x1d, 0xec, 0xe2, 0x9b, 0x80, 0xf3, 0x52, 0xc8, 0x52, 0x55, 0xfc, 0x8c, 0x41, 0x4e, 0xe1,
	0x30, 0x15, 0x8c, 0x25, 0x75, 0x43, 0x55, 0x96, 0x46, 0x94, 0xd0, 0x52, 0x55, 0xe4, 0x70, 0xbd,
	0x05, 0x7b, 0x74, 0x37, 0x6c, 0x7f, 0x3f, 0xec, 0xa3, 0x7d, 0xb0, 0xc7, 0x7b, 0x60, 0x1f, 0xb7,
	0xb0, 0x75, 0x9c, 0xc8, 0x62, 0x8e, 0xb8, 0x9d, 0xd0, 0x18, 0x7a, 0xcf, 0xb1, 0xe4, 0x4c, 0x28,
	0x44, 0x3d, 0x0c, 0x2b, 0x4b, 0x43, 0x30, 0xab, 0x28, 0x11, 0xa9, 0x50, 0x48, 0xd9, 0x0a, 0x5d,
	0xa3, 0x5d, 0x6b, 0x89, 0x9c, 0xc1, 0x80, 0x89, 0x32, 0xce, 0xd7, 0x99, 0x0a, 0xee, 0xa3, 0xbb,
	0xb1, 0x49, 0x00, 0xfd, 0x15, 0x4d, 0xa8, 0x7e, 0x5d, 0x80, 0xae, 0xda, 0x24, 0xe7, 0x30, 0xe9,
	0x9e, 0x70, 0x54, 0xd0, 0x4d, 0xca, 0x33, 0x15, 0x3c, 0xc0, 0xb0, 0xe3, 0xf6, 0xa4, 0x9f, 0x1b,
	0x07, 0xf9, 0x10, 0x46, 0x55, 0x4c, 0x64, 0xde, 0x75, 0x86, 0xfb, 0xf7, 0x2a, 0xf1, 0x29, 0xbe,
	0xef, 0x63, 0xf0, 0x19, 0x4f, 0xc4, 0xf7, 0x5c, 0x6e, 0xaa, 0xa8, 0xf7, 0x31, 0x6a, 0x54, 0xab,
	0x26, 0x8c, 0x40, 0x8f, 0x51, 0x45, 0x83, 0xe9, 0xcc, 0x5a, 0x78, 0x21, 0xae, 0xe7, 0x5f, 0xc3,
	0xe0, 0x4b, 0xfe, 0x0a, 0x5b, 0xe7, 0x5d, 0xf4, 0xca, 0xfc, 0x37, 0x1b, 0x9c, 0x77, 0x96, 0x5d,
	0xe7, 0x88, 0xab, 0x4e, 0xd7, 0x11, 0x3d, 0x93, 0xa3, 0x96, 0x96, 0x8c, 0x3c, 0x04, 0xe0, 0x99,
	0x92, 0x1b, 0x33, 0x4f, 0x80, 0x94, 0x87, 0xa8, 0xe0, 0x38, 0x3d, 0x04, 0x88, 0xa9, 0x94, 0xc2,
	0x3c, 0xee, 0x22, 0xb4, 0x61, 0xa5, 0x2c, 0x19, 0x59, 0xc0, 0xd8, 0x0c, 0x5a, 0x22, 0x32, 0x5e,
	0x91, 0xf5, 0x30, 0xc8, 0x47, 0xfd, 0x5a, 0x64, 0xdc, 0xa0, 0xfd, 0x04, 0x8e, 0x68, 0x92, 0x44,
	0x42, 0xf1, 0xb4, 0x8c, 0x92, 0x3c, 0xa6, 0x09, 0xf6, 0xf5, 0x20, 0x1c, 0xd1, 0x24, 0x59, 0x6a,
	0xf5, 0x5a, 0x8b, 0xe4, 0x23, 0xf0, 0x3b, 0x19, 0x0b, 0x25, 0x03, 0x7f, 0x76, 0xb0, 0xe8, 0x85,
	0x5e, 0x93, 0xef, 0xb9, 0x92, 0xf3, 0xbf, 0x6c, 0x18, 0x3e, 0xab, 0x05, 0x3d, 0x11, 0xcd, 0xb8,
	0x1b, 0x7c, 0xfd, 0xdc, 0x8c, 0xfa, 0x5b, 0x61, 0x78, 0x1f, 0xfa, 0x7a, 0xdb, 0x2d, 0xbf, 0x43,
	0x6d, 0x2e, 0x19, 0x79, 0x02, 0x27, 0xe5, 0xba, 0x28, 0x92, 0x4d, 0xb4, 0x95, 0xc2, 0xc1, 0xa0,
	0x63, 0xe3, 0xba, 0xe9, 0x24, 0x3a, 0x85, 0xc3, 0x6c, 0x9d, 0xae, 0xb8, 0x44, 0xce, 0x4e, 0x58,
	0x59, 0xba, 0x85, 0x9b, 0xee, 0xc4, 0x63, 0x70, 0xf1, 0x18, 0xbc, 0x5a, 0xc4, 0x93, 0x38, 0x83,
	0xc1, 0x77, 0x6b, 0x9a, 0x29, 0x3d, 0xdf, 0x06, 0x71, 0x63, 0xeb, 0xc4, 0x34, 0x45, 0xf8, 0x23,
	0x7c, 0xb2, 0xb2, 0xc8, 0x05, 0x4c, 0xda, 0xea, 0xb3, 0x97, 0xb9, 0x4c, 0xa9, 0x12, 0x79, 0x86,
	0x9f, 0x0d, 0x2f, 0x3c, 0x69, 0x30, 0xb4, 0xae, 0xf9, 0x0b, 0xe8, 0xe9, 0xd3, 0xb8, 0xf3, 0x2e,
	0xec, 0xde, 0x08, 0x13, 0x70, 0x0a, 0x29, 0xe2, 0x7a, 0xbf, 0xc6, 0x68, 0x86, 0x68, 0xd2, 0x19,
	0xa2, 0x1f, 0x6d, 0x70, 0xbe, 0x52, 0x79, 0xfc, 0xed, 0x4e, 0xde, 0x0e, 0x5c, 0x7b, 0x0b, 0xee,
	0x7f, 0x38, 0x98, 0x2e, 0x12, 0x78, 0x03, 0xc9, 0x07, 0x30, 0xac, 0xcb, 0x2b, 0x03, 0x77, 0x76,
	0xb0, 0xf0, 0xc2, 0x56, 0xd8, 0xb9, 0x47, 0x0c, 0xd0, 0xee, 0x3d, 0xf2, 0x08, 0x5c, 0xd3, 0x53,
	0x71, 0xc3, 0xd5, 0x09, 0x01, 0x25, 0xd3, 0xd0, 0x8f, 0xc1, 0x93, 0x3c, 0xcd, 0x55, 0xdd, 0xf6,
	0xbe, 0xb9, 0x67, 0x8c, 0xb6, 0xfd, 0x39, 0xe9, 0x92, 0xf8, 0xc9, 0x86, 0xfe, 0x17, 0xa2, 0x54,
	0xb9, 0xdc, 0xbc, 0x39, 0x9c, 0xd6, 0xce, 0x70, 0xbe, 0x8d, 0xee, 0xfd, 0x14, 0x26, 0xcd, 0x4b,
	0xba, 0xc9, 0x4c, 0x2b, 0x93, 0xda, 0x77, 0xd5, 0x26, 0xbd, 0x84, 0x7b, 0xcd, 0x13, 0x7b, 0x1a,
	0xfb, 0xa4, 0x76, 0xde, 0x6c, 0xff, 0x61, 0xe8, 0x7c, 0x40, 0x70, 0xdd, 0xe9, 0x4a, 0x77, 0xab,
	0x2b, 0xf7, 0x60, 0xf9, 0x7c, 0xfc, 0xfb, 0xed, 0xd4, 0xfa, 0xe3, 0x76, 0x6a, 0xfd, 0x7d, 0x3b,
	0xb5, 0x7e, 0xfe, 0x67, 0xfa, 0xde, 0xea, 0x10, 0xff, 0xa5, 0x7d, 0xf6, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x41, 0x31, 0x3e, 0x7e, 0xbb, 0x09, 0x00, 0x00,
}

func (m *Warehouse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Warehouse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Street_1) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_1)))
		i += copy(dAtA[i:], m.Street_1)
	}
	if len(m.Street_2) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_2)))
		i += copy(dAtA[i:], m.Street_2)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Zip) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Zip)))
		i += copy(dAtA[i:], m.Zip)
	}
	if m.Tax != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tax))))
		i += 8
	}
	if m.YearToDate != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.YearToDate))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *District) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *District) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Street_1) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_1)))
		i += copy(dAtA[i:], m.Street_1)
	}
	if len(m.Street_2) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_2)))
		i += copy(dAtA[i:], m.Street_2)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Zip) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Zip)))
		i += copy(dAtA[i:], m.Zip)
	}
	if m.Tax != 0 {
		dAtA[i] = 0xa1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Tax))))
		i += 8
	}
	if m.YearToDate != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.YearToDate))))
		i += 8
	}
	if m.NextOrderId != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.NextOrderId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Customer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Customer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DistrictId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictId)))
		i += copy(dAtA[i:], m.DistrictId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if len(m.First) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.First)))
		i += copy(dAtA[i:], m.First)
	}
	if len(m.Middle) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Middle)))
		i += copy(dAtA[i:], m.Middle)
	}
	if len(m.Last) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Last)))
		i += copy(dAtA[i:], m.Last)
	}
	if len(m.Street_1) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_1)))
		i += copy(dAtA[i:], m.Street_1)
	}
	if len(m.Street_2) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Street_2)))
		i += copy(dAtA[i:], m.Street_2)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Zip) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Zip)))
		i += copy(dAtA[i:], m.Zip)
	}
	if m.Since != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.Since))
	}
	if len(m.Credit) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Credit)))
		i += copy(dAtA[i:], m.Credit)
	}
	if m.CreditLimit != 0 {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CreditLimit))))
		i += 8
	}
	if m.Discount != 0 {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Discount))))
		i += 8
	}
	if m.Balance != 0 {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i += 8
	}
	if m.YearToDatePayment != 0 {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.YearToDatePayment))))
		i += 8
	}
	if m.PaymentCount != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.PaymentCount))
	}
	if m.DeliveryCount != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.DeliveryCount))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DistrictId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictId)))
		i += copy(dAtA[i:], m.DistrictId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DistrictId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictId)))
		i += copy(dAtA[i:], m.DistrictId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if len(m.CustomerId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.CustomerId)))
		i += copy(dAtA[i:], m.CustomerId)
	}
	if m.EntryDate != 0 {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EntryDate))))
		i += 8
	}
	if m.CarrierId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.CarrierId))
	}
	if m.OrderLineCount != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.OrderLineCount))
	}
	if m.AllItemsLocal {
		dAtA[i] = 0x68
		i++
		if m.AllItemsLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.OrderLinePtr) > 0 {
		dAtA2 := make([]byte, len(m.OrderLinePtr)*10)
		var j1 int
		for _, num := range m.OrderLinePtr {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderLine) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if len(m.DistrictId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictId)))
		i += copy(dAtA[i:], m.DistrictId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if len(m.ItemId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.ItemId)))
		i += copy(dAtA[i:], m.ItemId)
	}
	if len(m.SupplyWarehouseId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.SupplyWarehouseId)))
		i += copy(dAtA[i:], m.SupplyWarehouseId)
	}
	if m.Number != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.Number))
	}
	if m.DeliveryDate != 0 {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryDate))))
		i += 8
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.Quantity))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x69
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i += 8
	}
	if len(m.DistrictInformation) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictInformation)))
		i += copy(dAtA[i:], m.DistrictInformation)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Price != 0 {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Stock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.ItemId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.ItemId)))
		i += copy(dAtA[i:], m.ItemId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if m.Quantity != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.Quantity))
	}
	if len(m.Districts) > 0 {
		for _, b := range m.Districts {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTpcc(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.YearToDate != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.YearToDate))
	}
	if m.OrderCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.OrderCount))
	}
	if m.RemoteCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(m.RemoteCount))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *History) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *History) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CustomerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.CustomerId)))
		i += copy(dAtA[i:], m.CustomerId)
	}
	if len(m.DistrictId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.DistrictId)))
		i += copy(dAtA[i:], m.DistrictId)
	}
	if len(m.WarehouseId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.WarehouseId)))
		i += copy(dAtA[i:], m.WarehouseId)
	}
	if len(m.CustomerDistrictId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.CustomerDistrictId)))
		i += copy(dAtA[i:], m.CustomerDistrictId)
	}
	if len(m.CustomerWarehouseId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.CustomerWarehouseId)))
		i += copy(dAtA[i:], m.CustomerWarehouseId)
	}
	if m.Date != 0 {
		dAtA[i] = 0x51
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Date))))
		i += 8
	}
	if m.Amount != 0 {
		dAtA[i] = 0x59
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i += 8
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTpcc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTpcc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Warehouse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_1)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_2)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Zip)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.Tax != 0 {
		n += 10
	}
	if m.YearToDate != 0 {
		n += 10
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *District) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_1)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_2)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Zip)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.Tax != 0 {
		n += 10
	}
	if m.YearToDate != 0 {
		n += 10
	}
	if m.NextOrderId != 0 {
		n += 2 + sovTpcc(uint64(m.NextOrderId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Customer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.DistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.First)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Middle)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Last)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_1)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Street_2)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	l = len(m.Zip)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.Since != 0 {
		n += 2 + sovTpcc(uint64(m.Since))
	}
	l = len(m.Credit)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.CreditLimit != 0 {
		n += 10
	}
	if m.Discount != 0 {
		n += 10
	}
	if m.Balance != 0 {
		n += 10
	}
	if m.YearToDatePayment != 0 {
		n += 10
	}
	if m.PaymentCount != 0 {
		n += 2 + sovTpcc(uint64(m.PaymentCount))
	}
	if m.DeliveryCount != 0 {
		n += 2 + sovTpcc(uint64(m.DeliveryCount))
	}
	l = len(m.Data)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.DistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.DistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.EntryDate != 0 {
		n += 9
	}
	if m.CarrierId != 0 {
		n += 1 + sovTpcc(uint64(m.CarrierId))
	}
	if m.OrderLineCount != 0 {
		n += 1 + sovTpcc(uint64(m.OrderLineCount))
	}
	if m.AllItemsLocal {
		n += 2
	}
	if len(m.OrderLinePtr) > 0 {
		l = 0
		for _, e := range m.OrderLinePtr {
			l += sovTpcc(uint64(e))
		}
		n += 1 + sovTpcc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderLine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.DistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.ItemId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.SupplyWarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovTpcc(uint64(m.Number))
	}
	if m.DeliveryDate != 0 {
		n += 9
	}
	if m.Quantity != 0 {
		n += 1 + sovTpcc(uint64(m.Quantity))
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.DistrictInformation)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	l = len(m.Data)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.ItemId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.Quantity != 0 {
		n += 1 + sovTpcc(uint64(m.Quantity))
	}
	if len(m.Districts) > 0 {
		for _, b := range m.Districts {
			l = len(b)
			n += 1 + l + sovTpcc(uint64(l))
		}
	}
	if m.YearToDate != 0 {
		n += 1 + sovTpcc(uint64(m.YearToDate))
	}
	if m.OrderCount != 0 {
		n += 1 + sovTpcc(uint64(m.OrderCount))
	}
	if m.RemoteCount != 0 {
		n += 1 + sovTpcc(uint64(m.RemoteCount))
	}
	l = len(m.Data)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *History) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.DistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.WarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.CustomerDistrictId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	l = len(m.CustomerWarehouseId)
	if l > 0 {
		n += 1 + l + sovTpcc(uint64(l))
	}
	if m.Date != 0 {
		n += 9
	}
	if m.Amount != 0 {
		n += 9
	}
	l = len(m.Data)
	if l > 0 {
		n += 2 + l + sovTpcc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTpcc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTpcc(x uint64) (n int) {
	return sovTpcc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Warehouse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Warehouse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Warehouse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tax = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearToDate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.YearToDate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *District) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: District: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: District: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Tax = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearToDate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.YearToDate = float64(math.Float64frombits(v))
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOrderId", wireType)
			}
			m.NextOrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextOrderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Customer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Customer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Customer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.First = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Middle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Middle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Last = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			m.Since = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Since |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CreditLimit = float64(math.Float64frombits(v))
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Discount = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearToDatePayment", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.YearToDatePayment = float64(math.Float64frombits(v))
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentCount", wireType)
			}
			m.PaymentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCount", wireType)
			}
			m.DeliveryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryDate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EntryDate = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierId", wireType)
			}
			m.CarrierId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLineCount", wireType)
			}
			m.OrderLineCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderLineCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllItemsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllItemsLocal = bool(v != 0)
		case 14:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTpcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderLinePtr = append(m.OrderLinePtr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTpcc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTpcc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTpcc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OrderLinePtr) == 0 {
					m.OrderLinePtr = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTpcc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderLinePtr = append(m.OrderLinePtr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLinePtr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyWarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyWarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryDate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryDate = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictInformation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictInformation = append(m.DistrictInformation[:0], dAtA[iNdEx:postIndex]...)
			if m.DistrictInformation == nil {
				m.DistrictInformation = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Districts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Districts = append(m.Districts, make([]byte, postIndex-iNdEx))
			copy(m.Districts[len(m.Districts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearToDate", wireType)
			}
			m.YearToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YearToDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCount", wireType)
			}
			m.OrderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteCount", wireType)
			}
			m.RemoteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *History) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: History: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: History: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerDistrictId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerDistrictId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerWarehouseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerWarehouseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Date = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTpcc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTpcc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTpcc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTpcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTpcc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTpcc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTpcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTpcc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTpcc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTpcc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTpcc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTpcc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTpcc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTpcc   = fmt.Errorf("proto: integer overflow")
)
